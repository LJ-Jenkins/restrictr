% Generated by roxygen2: do not edit by hand
% Please edit documentation in R/schema_recycle.r
\name{schema_recycle}
\alias{schema_recycle}
\alias{schema_recycle.list}
\title{Ensure list elements are of a specific size and recycle them if not}
\usage{
schema_recycle(.data, ...)

\method{schema_recycle}{list}(
  .data,
  ...,
  .names = NULL,
  .size = NULL,
  .error_call = caller_env(),
  .darg = caller_arg(.data)
)
}
\arguments{
\item{.data}{a list to use as the data mask.}

\item{...}{any number of R expressions to be evaluated using \code{.data}
as a data mask. Should follow the format of \code{named_element = expected_size},
e.g, \code{var_x = 10} or \code{var_x = vctrs::vec_size(var_y)}.}

\item{.names}{optional character vector of names which must be
present in the \code{.data} data.frame/list. Can be a glue string.}

\item{.size}{optional positive scalar integerish value for the size that
the \code{.data} data.frame/list must have.}

\item{.error_call}{the call environment to use for error messages
(passed to \link[rlang:abort]{rlang::abort}).}

\item{.darg}{the argument name of \code{.data} to use in error messages.}
}
\value{
Object \code{.data}, with named elements recycled to the desired size.
Also attaches class "with_schema" and attribute "schema" containing the
schema_recycle call to be enforced later.
}
\description{
If any of the expressions in \code{...}, evaluated within the data mask
\code{.data} (see \link[rlang:args_data_masking]{rlang::args_data_masking}), are
not of the same size, then the data element attempts to be recycled to
the size specified in the expression. The \code{.names} and \code{.size}
arguments can be used to check for given names and size of the
list. The checking of size and the recycling are from the \link{vctrs}
(https://vctrs.r-lib.org/) package (using \link[vctrs:vec_size]{vctrs::vec_size} and
\link[vctrs:vec_recycle]{vctrs::vec_recycle}) and thus apply the \href{https://vctrs.r-lib.org/articles/type-size.html}{vctrs size rules}
and \href{https://vctrs.r-lib.org/reference/theory-faq-recycling.html}{vctrs recycling rules}.
}
\details{
See \link{schema} and \link{schema_cast}
for validation and casting, as well as \link{recycle_if_not}
for a non-data-masked version of recycling. \link{restrict}
can also be used for type casting, size recycling, and validation.
}
\examples{
# NB: Some of these examples are expected to produce an error. To
#     prevent them from terminating a run with example() they are
#     piped into a call to try().

li <- list(x = 1, y = "hi", z = 1:2)
schema_recycle(li, x = 5, y = 3) |> lengths()

# schema_recycle() follows `vctrs` recycling rules:
schema_recycle(li, z = 6) |> try()
# Error:
# Caused by error in `schema_recycle()`:
# ℹ In argument: `z = 6` for data mask `li`.
# ! Can't recycle `z` (size 2) to size 6.

# Other objects' lengths can be used as the size to
# recycle to, e.g.:
schema_recycle(li, x = vctrs::vec_size(z))$x |> length()

# schema_recycle() works sequentially, so references to objects will be
# after they have been evaluated:
li$a <- 1.25
schema_recycle(
  li,
  x = vctrs::vec_size(z),
  a = vctrs::vec_size(x)
)$a |> length()

# `.names` and `.size` arguments can be used to check that given names
# are present and that the data has the desired (vctrs) size:
schema_recycle(li, .names = c("a", "x", "y", "b")) |> try()
# Error:
# Caused by error in `schema_recycle()`.
# ! Named elements `a` and `b` not found in data mask `li`.

schema_recycle(li, .size = 5) |> try()
# Error:
# Caused by error in `schema_recycle()`.
# ! Object `li` is of vctrs size `3`, not `5`.


# The `.error_call` argument can be used to specify where the error occurs,
# by default this is the caller environment.
myfunc <- function(li, ...) schema_recycle(li, ...)
myfunc(li, x = -5) |> try()
# Error in `myfunc()`:
# Caused by error in `schema_recycle()`:
# ℹ In argument: `x = -5` for data mask `li`.
# ! Size argument is `-5`, needs to be positive scalar integerish.

# Injection and glue can be used:
li <- list(x = 1L)
x_name <- "x"
schema_recycle(li, "{x_name}" = 2)
schema_recycle(li, !!x_name := 2)
schema_recycle(li, {{ x_name }} := 2)
x_list <- list(x = 2)
schema_recycle(li, !!!x_list)
}
