% Generated by roxygen2: do not edit by hand
% Please edit documentation in R/recycle_if_not.r
\name{recycle_if_not}
\alias{recycle_if_not}
\title{Check if objects are of a specific size and recycle them if not}
\usage{
recycle_if_not(..., .env = caller_env(), .error_call = caller_env())
}
\arguments{
\item{...}{any number of named R expressions, in the form of:
\code{name_of_obj_to_cast = size_to_cast_to}}

\item{.env}{the environment to use for the evaluation of the recycling
expressions & the assignment of the recycled variables. Cannot be the global environment.}

\item{.error_call}{the call environment to use for the error (passed to \link[rlang:abort]{rlang::abort}).}
}
\description{
If any of the named expressions in \code{...} are not the specified size,
then the object attempts to be recycled to the size specified in the expression.
Expressions are evaluated and variables are assigned into the environment
specified by the \code{.env} argument. The checking of size and the recycling
are from the \href{https://vctrs.r-lib.org/}{vctrs} package (using \link[vctrs:vec_size]{vctrs::vec_size}
and \link[vctrs:vec_recycle]{vctrs::vec_recycle}) and thus stick to the \href{https://vctrs.r-lib.org/reference/theory-faq-recycling.html}{vctrs recycling rules}.
}
\examples{
# Will not alter the global environment so most examples here are wrapped with local().
x <- 1
recycle_if_not(x = 1) |> try()
# => Error: Argument `call` cannot be the global environment.

local({
  x <- 1
  recycle_if_not(x = 3)
  x
})

local({
  x <- rep(1, 4)
  recycle_if_not(x = 1) |> try()
})
# => Error : Can't recycle `x` (size 4) to size 1.

local({
  x <- 1L
  y <- 2.3
  recycle_if_not(x = 3, y = 2)
  cat(x, y, sep = ", ")
})

# beware when using other objects as the size argument, e.g.:
local({
  x <- 1L
  y <- c(1, 1, 1)
  recycle_if_not(x = y) |> try()
})
# => Error : Size argument for `x` is not a scalar integerish value:
# object length `3` of class <numeric>.

# when using other objects, call vctrs::vec_size() on them first:
local({
  x <- 1L
  y <- c(1, 1, 1)
  recycle_if_not(x = vctrs::vec_size(y))
  x
})

# recycle_if_not works sequentially, so references to objects will
# be after they have been evaluated:
local({
  x <- y <- 1
  recycle_if_not(x = 3, y = vctrs::vec_size(x))
  cat(length(x), length(y), sep = ", ")
})

myfunc <- \(x) {
  recycle_if_not(x = 3)
  x
}
x <- 1L
myfunc(x) # x is recycled to length 3 within the function
x # x is still scalar outside the function

local({
  x <- 1
  y <- 2
  z <- 3
  recycle_if_not(x = 2, y = 3, z = 4)
  cat(x, y, z, sep = ", ")
})

# the `.env` argument determines the expression and assignment environment:
local({
  x <- 1
  e <- new.env()
  e$x <- 1
  recycle_if_not(x = 3, .env = e)
  cat(length(e$x), length(x), sep = ", ")
})

# names (lhs) are checked to be in the `.env` environment,
# throwing an error if not found:
local({
  x <- 1
  e <- new.env()
  recycle_if_not(x = 3, .env = e) |> try()
})
# Error: Objects `x` are not found in the `.env` environment specified.

# for expressions (rhs), the `.env` argument is preferentially chosen,
# but if not found then the normal R scoping rules apply:
local({
  x <- 3
  e <- new.env()
  e$z <- 1
  recycle_if_not(z = x, .env = e)
  cat(e$z)
})
}
