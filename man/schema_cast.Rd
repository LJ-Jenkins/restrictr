% Generated by roxygen2: do not edit by hand
% Please edit documentation in R/schema_cast.r
\name{schema_cast}
\alias{schema_cast}
\alias{schema_cast.data.frame}
\alias{schema_cast.list}
\title{Ensure data.frame/list elements are of a specific type and cast them if not}
\usage{
schema_cast(.data, ...)

\method{schema_cast}{data.frame}(
  .data,
  ...,
  .lossy = FALSE,
  .names = NULL,
  .size = NULL,
  .error_call = caller_env()
)

\method{schema_cast}{list}(
  .data,
  ...,
  .lossy = FALSE,
  .names = NULL,
  .size = NULL,
  .error_call = caller_env()
)
}
\arguments{
\item{.data}{a data.frame or list to check the types schema of.}

\item{...}{any number of \code{\link[rlang:args_data_masking]{data-masking}}
name-value pairs to be evaluated using \code{.data} as a data-mask.
Should follow the format of \code{name = expected_type()},
e.g, \code{var_x = integer()} or \code{var_x = var_y}.}

\item{.lossy}{logical, if \code{TRUE} allow \link[vctrs:vctrs-conditions]{lossy casts}.}

\item{.names}{optional character vector of names which must be
present in the data.frame/list.}

\item{.size}{optional scalar integerish value for the size that
the data.frame/list must have.}

\item{.error_call}{the call environment to use for the error (passed to \link[rlang:abort]{rlang::abort}).}
}
\description{
If any of the data-masked named expressions in \code{...} are not of the same type,
then the object attempts to be cast to the type specified in the expression.
\code{.names} and \code{.size} arguments can be used to check for given names and size
of the data.frame/list. The checking of type and the type conversion are from the
\href{https://vctrs.r-lib.org/}{vctrs} package (using \link[vctrs:vec_assert]{vctrs::vec_is}
and \link[vctrs:vec_cast]{vctrs::vec_cast}) and thus stick to the \href{https://vctrs.r-lib.org/reference/faq-compatibility-types.html}{vctrs type conversion rules}.
The checking of size is also from \href{https://vctrs.r-lib.org/}{vctrs}
(using \link[vctrs:vec_size]{vctrs::vec_size}) and thus applies vctrs size rules.
}
\details{
See also \link[=schema]{schema} and \link[=schema_recycle]{schema_recycle},
as well as \link[=cast_if_not]{cast_if_not} for a non-data-masked version of casting.
}
\examples{
# NB: Some of these examples are expected to produce an error. To
#     prevent them from terminating a run with example() they are
#     piped into a call to try().

li <- list(x = 1.1, y = "hi", z = 1L:2L)
# input remains the same if types match
li |>
  schema_cast(x = double(), y = character(), z = integer()) |>
  lapply(class)

li |>
  schema_cast(y = numeric()) |>
  try()
# => Error: Can't convert `y` <character> to <double>.

li |>
  schema_cast(x = z) |>
  try()
# => Error: Can't convert from `x` <double> to <integer> due to loss of precision.

# with lossy casting
li |>
  schema_cast(x = z, .lossy = TRUE) |>
  lapply(class)

# schema_cast works sequentially with quosures, so references to objects will be
# after they have been evaluated:
li$a <- 1L
li |>
  schema_cast(z = x, a = z) |>
  lapply(class)

li |>
  schema_cast(x = numeric(), .size = 5) |>
  try()
# => Error: Object `li` must have vctrs size `5`, not `4`.

li |>
  schema_cast(x = numeric(), .names = c("x", "p")) |>
  try()
# => Error: Names `p` not found in `li`.

# injection and glue can be used to supply expressions, names, and messages:
li <- list(x = 1L, z = 5.5)
x_name <- "x"
schema_cast(li, !!x_name := z) |>
  lapply(class)
xg_name <- "{x_name}"
schema_cast(li, {{ xg_name }} := character()) |> try()
# => Error: Can't convert `x` <integer> to <character>.
}
