% Generated by roxygen2: do not edit by hand
% Please edit documentation in R/restrict.r
\name{restrict}
\alias{restrict}
\title{Restrict arguments to a specific type/size and test adherence to
validation functions/formulas.}
\usage{
restrict(..., .env = caller_env(), .error_call = caller_env())
}
\arguments{
\item{...}{any number of named R expressions, with the names referring to objects
in the environment specified by the \code{.env} argument, and the expressions built
using the functions: \code{validate()}, \code{cast()}, \code{lossy_cast()}, \code{recycle()}, and \code{coerce()}.}

\item{.env}{the environment to use for the evaluation of the expressions & the
(possible) assignment of the variables. Cannot be the global environment.}

\item{.error_call}{the call environment to use for the error (passed to \link[rlang:abort]{rlang::abort}).}
}
\description{
This function takes any number of named expressions referring to objects
in the given environment, checking and possibly coercing them to the specified
type and/or size, and also checking them against any number of validation
functions/formulas. Using the function keywords of \code{validate}, \code{cast},
\code{lossy_cast}, \code{recycle}, and \code{coerce} within the expressions allows for
different behaviours:
\itemize{
\item \code{validate}: checks that the object is of the specified type/size and
adheres to the validations, throwing an error if not.
\item \code{cast}: differs from validate by checking that the object is of the
specified type, and if not attempts to cast it to that type
(throwing an error if not possible).
\item \code{lossy_cast}: differs from \code{cast} by allowing lossy casting
(e.g. double to integer).
\item \code{recycle}: differs from \code{validate} by checking that the object is of
the specified size, and if not attempts to recycle it to that size
(throwing an error if not possible).
\item \code{coerce}: differs from \code{validate} by checking both the type and size,
and attempting to cast and/or recycle it to that type/size
(throwing an error if not possible). Casting is not lossy by default but
can be made lossy by adding \code{lossy = TRUE} within the \code{coerce()} call.
}
}
\details{
These functions accept the named arguments \code{type}, \code{size} and \code{mask}
(\code{lossy} is also accepted within \code{coerce()}):
\itemize{
\item \code{type}: an R object of the desired type (e.g. \code{integer()}, \code{double()},
\code{character()}, \code{list()}). The type checking and casting are done using
the \href{https://vctrs.r-lib.org/}{vctrs} package (using \link[vctrs:vec_assert]{vctrs::vec_is} and
\link[vctrs:vec_cast]{vctrs::vec_cast}) and thus stick to the \href{https://vctrs.r-lib.org/reference/faq-compatibility-types.html}{vctrs type conversion rules}.
\item \code{size}: a scalar integerish value specifying the desired size. The size
checking and recycling are done using the \href{https://vctrs.r-lib.org/}{vctrs}
package (using \link[vctrs:vec_size]{vctrs::vec_size} and \link[vctrs:vec_recycle]{vctrs::vec_recycle}) and thus stick to
the \href{https://vctrs.r-lib.org/reference/theory-faq-recycling.html}{vctrs recycling rules}.
\item \code{mask}: an optional data frame or list to use as a data mask for
evaluations. Expressions are evaluated using \link[rlang:eval_tidy]{rlang::eval_tidy} with
the \code{data} argument set to the mask and the \code{env} argument set to the
environment specified by the \code{.env} argument to \code{restrict()}.
The mask must be present within the environment.
\item \code{na_rm}: if TRUE, NA values are removed in the logical vectors from the validations before evaluating (default is FALSE).
}

All other inputs should be unnamed validations: either expressions or formulas
(that evaluate to logical). \code{restrict} first evaluates type, then size, then the
validations. Any change from the prior expression is reflected in subsequent
expressions, i.e. if an object is cast to a new type then that new type is
used for the size check and validations.
If you do not wish to use the \href{https://vctrs.r-lib.org/}{vctrs} type/size checking,
then instead give validations functions such as \code{~ is.integer(.x)}.
However, these will only validate, not cast or recycle.
\code{restrict} is designed for the checking of numerous objects, for a smaller number of
objects to check see the \link{abort_if_not}, \link{cast_if_not},
\link{recycle_if_not}, \link{schema}, \link{schema_cast} and
\link{schema_recycle} functions.
}
\examples{
# Will not alter the global environment so most examples here are wrapped with local().
x <- 1L
restrict(x = validate(type = integer())) |> try()
# => Error : Argument `.env` cannot be the global environment.

local({
  x <- 1L
  restrict(x = coerce(type = double(), size = 3))
  cat(class(x), length(x), sep = ", ")
})

local({
  x <- 1.5
  restrict(x = cast(type = integer())) |> try()
})
# => Error : Can't convert from `x` <double> to <integer> due to loss of precision.

local({
  x <- 1.5
  restrict(x = lossy_cast(type = integer()))
  cat(x, class(x), sep = ", ")

  # or

  x <- 1.5
  restrict(x = coerce(type = integer(), lossy = TRUE))
  cat(x, class(x), sep = ", ")
})

# other objects can be used as the type to cast to or size to recycle to, e.g.:
local({
  x <- 1L
  y <- 2.3
  z <- 3L
  restrict(x = coerce(type = y, size = z))
  cat(class(x), length(x), sep = ", ")
})

# restrict works sequentially, so references to objects will be
# after they have been evaluated:
local({
  x <- y <- 1L
  restrict(
    x = cast(type = double()),
    y = cast(type = x)
  )
  cat(class(x), class(y), sep = ", ")
})

# numerous validations can be given and type and size checking can be done
# within if base R checking is preferred:
local({
  x <- 1L
  restrict(
    x = validate(
      ~ is.integer(.x),
      ~ length(.x) == 1,
      \(y) all(y > 0),
      \(z) !is.character(z)
    )
  )
})

# the `.env` argument determines the expression and assignment environment:
local({
  x <- 1L
  e <- new.env()
  e$x <- 1L
  restrict(x = cast(type = 1.5), .env = e)
  cat(class(e$x), class(x), sep = ", ")
})

# names (lhs) are checked to be in the `.env` environment, throwing an error if not found:
local({
  x <- 1L
  e <- new.env()
  restrict(x = cast(type = 1.5), .env = e) |> try()
})
# => Error: Objects `x` are not found in the `.env` environment specified.

# for expressions (rhs), the `.env` argument is preferentially chosen, but if not found
# then the normal R scoping rules apply:
local({
  x <- 1.5
  e <- new.env()
  e$z <- 1L
  restrict(x = cast(type = x), .env = e) |> try()
  cat(class(e$z))
})
}
