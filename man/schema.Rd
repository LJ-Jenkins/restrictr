% Generated by roxygen2: do not edit by hand
% Please edit documentation in R/schema.r
\name{schema}
\alias{schema}
\alias{schema.data.frame}
\alias{schema.list}
\title{Ensure the truth of data-masked R expressions}
\usage{
schema(.data, ...)

\method{schema}{data.frame}(
  .data,
  ...,
  .na_rm = FALSE,
  .names = NULL,
  .size = NULL,
  .message = NULL,
  .error_call = caller_env(),
  .darg = caller_arg(.data)
)

\method{schema}{list}(
  .data,
  ...,
  .na_rm = FALSE,
  .names = NULL,
  .size = NULL,
  .message = NULL,
  .error_call = caller_env(),
  .darg = caller_arg(.data)
)
}
\arguments{
\item{.data}{a data.frame or list to use as the data mask.}

\item{...}{any number of R expressions to be evaluated using \code{.data}
as a data mask, which should each evaluate to (a logical vector of \link{all})
\code{TRUE} for no error to occur. Positive numbers are not \code{TRUE}, even
when they are coerced to \code{TRUE} inside \verb{if()} or in arithmetic
computations in R. If the expressions are named, the names will be
used in the error message. Names support \link{rlang injection}
(https://rlang.r-lib.org/reference/topic-inject.html) and \link{glue}
(https://glue.tidyverse.org/) interpreted string literals.}

\item{.na_rm}{if \code{TRUE}, NA values are removed in the logical vectors
before evaluation.}

\item{.names}{optional character vector of names which must be
present in the \code{.data} data.frame/list. Can be a glue string.}

\item{.size}{optional positive scalar integerish value for the size that
the \code{.data} data.frame/list must have.}

\item{.message}{single default error message for non-named expressions.
Can be a glue string.}

\item{.error_call}{the call environment to use for error messages
(passed to \link[rlang:abort]{rlang::abort}).}

\item{.darg}{the argument name of \code{.data} to use in error messages.}
}
\value{
.data is returned with attached class "with_schema" and
attribute "schema" containing the schema call to be enforced later.
}
\description{
If any of the expressions in \code{...}, evaluated within the data mask
\code{.data} (see \href{rlang::args_data_masking}{rlang data masking}), are
not all \code{TRUE}, \link[rlang:abort]{rlang::abort} is called for the first expression
which was not (\link{all}) \code{TRUE}. The \code{.names} and \code{.size} arguments
can be used to check for given names and size of the
data.frame/list. The checking of size is from the \link{vctrs}
(https://vctrs.r-lib.org/) package (using \link[vctrs:vec_size]{vctrs::vec_size}) and
thus applies \link{vctrs size rules}
(https://vctrs.r-lib.org/articles/type-size.html).
}
\details{
See \href{restrictr::schema_cast}{schema_cast} and \link{schema_recycle}
(restrictr::schema_recycle) for versions of \code{schema()} that attempt
to coerce named elements of the data to the desired type/size. See
\href{restrictr::abort_if_not}{abort_if_not} for a non-data-masked version
of this function. \href{restrictr::restrict}{restrict} can also be used for
type casting, size recycling, and validation.
}
\examples{
# NB: Some of these examples are expected to produce an error. To
#     prevent them from terminating a run with example() they are
#     piped into a call to try().

li <- list(x = 1, y = "hi", z = \(x) x > 1)
li <- schema(li, x == 1, is.character(y), is.function(z)) # all TRUE

schema(li, x == 1, is.numeric(y)) |> try()
# Error:
# Caused by error in `schema()`:
# ℹ In argument: `is.numeric(y)` for data mask `li`.
# ! Returned `FALSE`.

# A custom error message can be given for each expression:
schema(li, "y must be numeric, check input" = is.numeric(y)) |> try()
# Error:
# Caused by error in `schema()`:
# ℹ In argument: `is.numeric(y)` for data mask `li`.
# ! y must be numeric, check input

# Alternatively, one error message can be used for all expressions:
schema(
  li,
  x == 1, is.character(y), is.integer(z),
  .message = "li is invalid, check input"
) |> try()
# Error:
# Caused by error in `schema()`:
# ℹ In argument: `is.integer(z)` for data mask `li`.
# ! li is invalid, check input

# Option to remove NA values before checking:
df <- data.frame(x = c(5, NA, 10))
df <- schema(df, x > 4, .na_rm = TRUE) # no error

# `.names` and `.size` arguments can be used to check that given names
# are present and that the data has the desired (vctrs) size:
schema(li, .names = c("a", "x", "y", "b")) |> try()
# Error:
# Caused by error in `schema()`.
# ! Named elements `a` and `b` not found in data mask `li`.

schema(li, .size = 5) |> try()
# Error:
# Caused by error in `schema()`.
# ! Object `li` is of vctrs size `3`, not `5`.

# The `.error_call` argument can be used to specify where the error occurs,
# by default this is the caller environment.
myfunc <- function(df, ...) schema(df, ...)
myfunc(df, x > 4) |> try()
# Error in `myfunc()`:
# Caused by error in `schema()`:
# ℹ In argument: `x > 4` for data mask `df`.
# ! Contains `NA` values and `.na_rm` is set to `FALSE`.

# Injection and glue can be used:
y <- "my error"
schema(li, "{y}" = x == 2) |> try()
schema(li, {{ y }} := x == 2) |> try()
schema(li, !!y := x == 2) |> try()
schema(li, x == 2, .message = "{y}") |> try()
# Error:
# Caused by error in `schema()`:
# ℹ In argument: `x == 2` for data mask `li`.
# ! my error
y <- list("my bang-bang-bang error" = rlang::expr(x == 2))
schema(li, !!!y) |> try()
# Error:
# Caused by error in `schema()`:
# ℹ In argument: `x == 2` for data mask `li`.
# ! my bang-bang-bang error
}
