% Generated by roxygen2: do not edit by hand
% Please edit documentation in R/schema.r
\name{schema}
\alias{schema}
\alias{schema.data.frame}
\alias{schema.list}
\title{Ensure data.frame/list elements conform to a given schema}
\usage{
schema(.data, ...)

\method{schema}{data.frame}(
  .data,
  ...,
  .names = NULL,
  .size = NULL,
  .message = NULL,
  .na_rm = FALSE,
  .error_call = caller_env()
)

\method{schema}{list}(
  .data,
  ...,
  .names = NULL,
  .size = NULL,
  .message = NULL,
  .na_rm = FALSE,
  .error_call = caller_env()
)
}
\arguments{
\item{.data}{a data.frame or list to check the schema of.}

\item{...}{any number of R expressions to be evaluated using \code{.data}
as a data-mask, which should each evaluate to (a logical vector of all)
\code{TRUE} for no error to occur.}

\item{.names}{optional character vector of names which must be
present in the data.frame/list.}

\item{.size}{optional scalar integerish value for the size of that
the data.frame/list must have.}

\item{.message}{single default error message for non-named expressions.}

\item{.na_rm}{if TRUE, NA values are removed in the logical vectors (default is FALSE)}

\item{.error_call}{the call environment to use for the error (passed to \link[rlang:abort]{rlang::abort}).}
}
\description{
If any of the data-masked expressions in \code{...} are not all \code{TRUE},
\link[rlang:abort]{rlang::abort} is called for the first expression which was not
(all) \code{TRUE}. \code{.names} and \code{.size} arguments can be used to check for
given names and size of the data.frame/list. The checking of size is from
the \href{https://vctrs.r-lib.org/}{vctrs} package (using \link[vctrs:vec_size]{vctrs::vec_size}) and
thus applies vctrs size rules.
}
\details{
\link[=schema_cast]{schema_cast} and \link[=schema_recycle]{schema_recycle}
are versions of \code{schema()} that attempt to coerce the data to the desired schema.
}
\examples{
# NB: Some of these examples are expected to produce an error. To
#     prevent them from terminating a run with example() they are
#     piped into a call to try().

li <- list(x = 1, y = "hi", z = \(x) x > 1)
li |>
  schema(x == 1, is.character(y), is.function(z)) # all TRUE

li |>
  schema(x == 1, is.numeric(y)) |>
  try()
# => Error: Argument `is.numeric(y)` for data mask `.data` returned `FALSE`.

li |>
  schema(length(x)) |>
  try()
# => Error: Expression `length(x)` for object `.data` must evaluate to class
# <logical> not <integer>.
# even when if(1) "ok" works

# The default error message can be overridden to be more informative:
df <- data.frame(a = 1L:3L, b = c("x", "y", "z"))
df |>
  schema("a must be double" = is.double(a)) |>
  try()
# => Error: a must be double

# Alternatively, one error message can be used for all expressions:
df |>
  schema(
    is.integer(a),
    !grepl("x", b),
    .message = "a must be integer and b cannot contain 'x'."
  ) |>
  try()
# => Error: a must be integer and b cannot contain 'x'.

# injection and glue can be used to supply expressions, names, and messages:
x <- "my error"
schema(df, "{x}" = FALSE) |> try()
# => Error: my error
y <- FALSE
schema(df, {{ x }} := !!y) |> try()
# => Error: my error
schema(df, !!x := !is.character(b)) |> try()
# => Error: my error
x <- list("my error" = FALSE)
schema(df, !!!x) |> try()
# => Error: my error
}
