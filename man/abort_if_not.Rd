% Generated by roxygen2: do not edit by hand
% Please edit documentation in R/abort_if_not.r
\name{abort_if_not}
\alias{abort_if_not}
\alias{abort_if}
\title{Ensure the truth of R expressions}
\usage{
abort_if_not(..., .na_rm = FALSE, .message = NULL, .error_call = caller_env())
}
\arguments{
\item{...}{any number of R expressions, which should each evaluate to
(a logical vector of \link{all}) \code{TRUE} for no error to occur. Positive numbers
are not \code{TRUE}, even when they are coerced to \code{TRUE} inside \verb{if()} or in
arithmetic computations in R. If the expressions are named, the names
will be used in the error message. Names support
\href{https://rlang.r-lib.org/reference/topic-inject.html}{rlang injection} and
\href{https://glue.tidyverse.org/}{glue} interpreted string literals.}

\item{.na_rm}{if \code{TRUE}, NA values are removed in the logical vectors
before evaluation.}

\item{.message}{single default error message for non-named expressions.
Can be a glue string.}

\item{.error_call}{the call environment to use for error messages
(passed to \link[rlang:abort]{rlang::abort}).}
}
\value{
NULL, called for side effects only.
}
\description{
If any of the expressions in \code{...} are not all \code{TRUE}, \link[rlang:abort]{rlang::abort} is
called for the first expression which was not (\link{all}) \code{TRUE}. A replacement
for \link{stopifnot} that utilises \link{rlang}, \link{cli}, and \link{glue}.
}
\details{
\code{abort_if()} is the opposite of \code{abort_if_not()}, i.e. expressions
should evaluate to (\link{all}) \code{FALSE} for no error to occur.
}
\examples{
# NB: Some of these examples are expected to produce an error. To
#     prevent them from terminating a run with example() they are
#     piped into a call to try().

abort_if_not(1 == 1, all.equal(pi, 3.14159265), 1 < 2) # all TRUE

m <- matrix(c(1, 3, 3, 1), 2, 2)
abort_if_not(m == t(m), diag(m) == rep(1, 2)) # all TRUE

abort_if_not(1) |> try()
# Error:
# Caused by error in `abort_if_not()`:
# ℹ In argument: `1`.
# ! Returned <integer>, not <logical>.

# A custom error message can be given for each expression:
m[1, 2] <- 12
abort_if_not("m must be symmetric" = m == t(m)) |> try()
# Error:
# Caused by error in `abort_if_not()`:
# ℹ In argument: `m == t(m)`.
# ! m must be symmetric

# Alternatively, one error message can be used for all expressions:
abort_if_not(
  m == t(m),
  diag(m) == rep(1, 2),
  .message = "m must be symmetric and have 1s on the diagonal."
) |> try()
# Error:
# Caused by error in `abort_if_not()`:
# ℹ In argument: `m == t(m)`.
# ! m must be symmetric and have 1s on the diagonal.

# Option to remove NA values before checking:
abort_if_not(c(TRUE, NA, TRUE), .na_rm = TRUE) # no error

# The `.error_call` argument can be used to specify where the error occurs,
# by default this is the caller environment.
myfunc <- function(x) abort_if_not(x)
myfunc(FALSE) |> try()
# Error in `myfunc()`:
# Caused by error in `abort_if_not()`:
# ℹ In argument: `x`.
# ! Returned `FALSE`.

# abort_if() errors if any argument does not evaluate to (all) FALSE.
abort_if(1 == 1) |> try()
# Error:
# Caused by error in `abort_if()`:
# ℹ In argument: `1 == 1`.
# ! Returned `TRUE`.

# Injection and glue can be used:
x <- "my error"
abort_if_not("{x}" = FALSE) |> try()
abort_if_not({{ x }} := FALSE) |> try()
abort_if_not(!!x := FALSE) |> try()
abort_if_not(FALSE, .message = "{x}") |> try()
# Error:
# Caused by error in `abort_if_not()`:
# ℹ In argument: `FALSE`.
# ! my error
x <- list("my bang-bang-bang error" = FALSE)
abort_if_not(!!!x) |> try()
# Error:
# Caused by error in `abort_if_not()`:
# ℹ In argument: `FALSE`.
# ! my bang-bang-bang error
}
