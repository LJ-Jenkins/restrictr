[{"path":"https://lj-jenkins.github.io/restrictr_test/authors.html","id":null,"dir":"","previous_headings":"","what":"Authors","title":"Authors and Citation","text":"Luke Jenkins. Author, maintainer.","code":""},{"path":"https://lj-jenkins.github.io/restrictr_test/authors.html","id":"citation","dir":"","previous_headings":"","what":"Citation","title":"Authors and Citation","text":"Jenkins L (2025). restrictr: Function Argument Validation. R package version 0.0.0.9000, https://lj-jenkins.github.io/restrictr/.","code":"@Manual{,   title = {restrictr: Function Argument Validation},   author = {Luke Jenkins},   year = {2025},   note = {R package version 0.0.0.9000},   url = {https://lj-jenkins.github.io/restrictr/}, }"},{"path":"https://lj-jenkins.github.io/restrictr_test/index.html","id":"restrictr-","dir":"","previous_headings":"","what":"Function Argument Validation","title":"Function Argument Validation","text":"restrictr provides tools validation safe type coercion/recycling function arguments. Note: package still development stage subject change.","code":""},{"path":"https://lj-jenkins.github.io/restrictr_test/index.html","id":"overview","dir":"","previous_headings":"","what":"Overview","title":"Function Argument Validation","text":"abort_if_not() general validation. cast_if_not() recycle_if_not() safe type casting recycling variables. schema() validation named elements data.frames/lists. schema_cast() schema_recycle() safe type casting recycling named elements data.frames/lists. restrict() validation, safe type casting safe recycling variables named elements data.frames/lists.","code":""},{"path":"https://lj-jenkins.github.io/restrictr_test/index.html","id":"installation","dir":"","previous_headings":"","what":"Installation","title":"Function Argument Validation","text":"can install development version restrictr GitHub :","code":"# install.packages(\"pak\") pak::pak(\"LJ-Jenkins/restrictr\")"},{"path":"https://lj-jenkins.github.io/restrictr_test/index.html","id":"examples","dir":"","previous_headings":"","what":"Examples","title":"Function Argument Validation","text":"abort_if_not can used validations: cast_if_not recycle_if_not provide safe casting recycling vctrs. Variables provided left hand side expected type/size provided right. Assignment automatically done back environment specified (default caller_env()): schema, schema_cast schema_recycle provide functionality data-masked arguments data.frames/lists. size data.frame/list whether certain names present can also checked using .names .size arguments. data-mask object returned (unaltered schema): restrict combines functionality multi-purpose tool. variables named elements within data.frames/lists can validated casted/recycled. keyword functions validate, cast, lossy_cast, recycle coerce determines whether type casting /recycling occurs. Validation functions can given, either form functions lambdas. Assignment occurs back environment specified (default caller_env()). contradictory example just show features:","code":"library(restrictr)  f <- \\(x, y) {   abort_if_not(     is.character(x),     \"`{x}` is too short!\" = nchar(x) > 5,     y$x == 1   ) }  # f(1L, list(x = 1)) # Error in `f()`: # Caused by error in `abort_if_not()`: # ℹ In argument: `is.character(x)`. # ! Returned `FALSE`.  # f(\"hi\", list(x = 1)) # Error in `f()`: # Caused by error in `abort_if_not()`: # ℹ In argument: `nchar(x) > 5`. # ! `hi` is too short! f <- \\(x, y) {   cast_if_not(x = double())   recycle_if_not(y = x)    print(class(x))   print(length(y)) }  # f(5L, 1) # [1] \"numeric\" # [1] 5  f <- \\(x) {   cast_if_not(x = integer(), .lossy = TRUE)    print(x) }  # f(1.5) # [1] 1  # f(\"hi\") # Error in `f()`: # Caused by error in `cast_if_not()`: # ℹ In argument: `x = integer()`. # ! Can't convert `x` <character> to <integer>. f <- \\(df) {   df <- df |>     schema(x == 1) }  # f(data.frame(x = 2)) # Error in `f()`: # Caused by error in `schema()`: # ℹ In argument: `x == 1` for data mask `df`. # ! Returned `FALSE`.  f <- \\(df) {   df <- df |>     schema_cast(x = double())    print(class(df$x)) }  # f(data.frame(x = 1L)) # [1] \"numeric\"  # schema_recycle is only implemented for lists. f <- \\(li) {   li <- li |>     schema_recycle(x = 3, y = 5, z = vctrs::vec_size(x))    print(lengths(li)) }  # f(list(x = 1, y = 1, z = 1)) # x y z # 3 5 3 f <- \\(df, x) {   restrict(     df = validate(       type = data.frame(x = integer()),       size = 1,       ~ ncol(.x) == 1,       \\(.x) colnames(.x) == \"x\"     ),     x = cast(type = .env$x, mask = df),     x = coerce(type = integer(), size = df$x, lossy = TRUE)   )    cat(\"`df$x` casted to\", class(df$x), \"from the initial `x` class \\n\")   cat(\"`x` lossily casted to\", class(x), \"and recycled using value of `df$x` to length\", length(x)) }  # f(data.frame(x = 3L), 1.5) # `df$x` casted to numeric from the initial `x` class # `x` lossily casted to integer and recycled using value of `df$x` to 3  #-- vctrs type/size rules are for all `cast`, `recycle` and `coerce` calls within restrictr functions f <- \\(df) {   restrict(df = validate(type = data.frame(x = integer(), y = double()))) }  # f(data.frame(x = 1L, y = \"hi\")) # Error in `f()`: # Caused by error in `restrict()`: # ℹ In argument: `df`. # ! Returned <data.frame<\/ x: integer/ y: character/>>, not <data.frame<\/ x: integer/ y: double/>>.  f <- \\(x) {   restrict(x = recycle(size = 10)) }  # f(1:5) # Error in `f()`: # Caused by error in `restrict()`: # ℹ In argument: `x`. # ! Can't recycle `x` (size 5) to size 10."},{"path":"https://lj-jenkins.github.io/restrictr_test/index.html","id":"notes","dir":"","previous_headings":"Examples","what":"Notes","title":"Function Argument Validation","text":"restrictr restrict inspired MATLAB’s arguments block. restrictr functions clean-case errors. typical usage within functions, little impact. However, intend continue using variables associated environments, care taken. See following example:","code":"local({   x <- 1L   y <- 1L   cast_if_not(x = double(), y = character()) |> try()   cat(     \"Code has errored but `x` has still been casted to:\",     class(x), \"\\n\",     \"in the environment specified for the `cast_if_not` call.\"   ) }) #> Error in eval(quote({ : Caused by error in `cast_if_not()`: #> ℹ In argument: `y = character()`. #> ! Can't convert `y` <integer> to <character>. #> Code has errored but `x` has still been casted to: numeric  #>  in the environment specified for the `cast_if_not` call."},{"path":"https://lj-jenkins.github.io/restrictr_test/reference/abort_if_not.html","id":null,"dir":"Reference","previous_headings":"","what":"Ensure the Truth of R Expressions — abort_if_not","title":"Ensure the Truth of R Expressions — abort_if_not","text":"expressions ... TRUE, rlang::abort called first expression () TRUE. associated error message either (hierachy): name expression, message argument, expression .","code":""},{"path":"https://lj-jenkins.github.io/restrictr_test/reference/abort_if_not.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Ensure the Truth of R Expressions — abort_if_not","text":"","code":"abort_if_not(..., .message = NULL, .na_rm = FALSE, .error_call = caller_env())"},{"path":"https://lj-jenkins.github.io/restrictr_test/reference/abort_if_not.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Ensure the Truth of R Expressions — abort_if_not","text":"... number R expressions, evaluate (logical vector ) TRUE error occur. expressions named, names used error message. .message single default error message non-named expressions. .na_rm TRUE, NA values removed logical vectors (default FALSE) .error_call call environment use error (passed rlang::abort).","code":""},{"path":"https://lj-jenkins.github.io/restrictr_test/reference/abort_if_not.html","id":"details","dir":"Reference","previous_headings":"","what":"Details","title":"Ensure the Truth of R Expressions — abort_if_not","text":"abort_if() opposite abort_if_not(), .e. expressions evaluate () FALSE error occur.","code":""},{"path":"https://lj-jenkins.github.io/restrictr_test/reference/abort_if_not.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Ensure the Truth of R Expressions — abort_if_not","text":"","code":"# NB: Some of these examples are expected to produce an error. To #     prevent them from terminating a run with example() they are #     piped into a call to try().  abort_if_not(1 == 1, all.equal(pi, 3.14159265), 1 < 2) # all TRUE  m <- matrix(c(1, 3, 3, 1), 2, 2) abort_if_not(m == t(m), diag(m) == rep(1, 2)) # all TRUE  abort_if_not(length(10)) |> try() #> Error in eval(expr, envir) :  #>   Caused by error in `abort_if_not()`: #> ℹ In argument: `length(10)`. #> ! Returned <integer>, not <logical>. # => Error: Expression `length(10)` for object `.data` must evaluate to # class <logical> not <integer>. # even when if(1) \"ok\" works  # The default error message can be overridden to be more informative: m[1, 2] <- 12 abort_if_not(\"m must be symmetric\" = m == t(m)) |> try() #> Error in eval(expr, envir) :  #>   Caused by error in `abort_if_not()`: #> ℹ In argument: `m == t(m)`. #> ! m must be symmetric # => Error: m must be symmetric  # Alternatively, one error message can be used for all expressions: abort_if_not(   m == t(m),   diag(m) == rep(1, 2),   message = \"m must be symmetric and have 1s on the diagonal.\" ) |> try() #> Error in eval(expr, envir) :  #>   Caused by error in `abort_if_not()`: #> ℹ In argument: `m == t(m)`. #> ! Returned `FALSE`. # => Error: m must be symmetric and have 1s on the diagonal.  abort_if(1 == 1) |> try() # abort_if errors if any argument does not evaluate to (all) FALSE #> Error in eval(expr, envir) :  #>   Caused by error in `abort_if()`: #> ℹ In argument: `1 == 1`. #> ! Returned `TRUE`.  # injection and glue can be used to supply expressions, names, and messages: x <- \"my error\" abort_if_not(\"{x}\" = FALSE) |> try() #> Error in eval(expr, envir) :  #>   Caused by error in `abort_if_not()`: #> ℹ In argument: `FALSE`. #> ! my error # => Error: my error y <- FALSE abort_if_not({{ x }} := !!y) |> try() #> Error in eval(expr, envir) :  #>   Caused by error in `abort_if_not()`: #> ℹ In argument: `FALSE`. #> ! my error # => Error: my error abort_if_not(!!x := !!y) |> try() #> Error in eval(expr, envir) :  #>   Caused by error in `abort_if_not()`: #> ℹ In argument: `FALSE`. #> ! my error # => Error: my error x <- list(\"my error\" = FALSE) abort_if_not(!!!x) |> try() #> Error in eval(expr, envir) :  #>   Caused by error in `abort_if_not()`: #> ℹ In argument: `FALSE`. #> ! my error # => Error: my error"},{"path":"https://lj-jenkins.github.io/restrictr_test/reference/cast_if_not.html","id":null,"dir":"Reference","previous_headings":"","what":"Check if objects are of a specific type and cast them if not — cast_if_not","title":"Check if objects are of a specific type and cast them if not — cast_if_not","text":"named expressions ... type, object attempts cast type specified expression. Expressions evaluated variables assigned environment specified .env argument. checking type type conversion vctrs package (using vctrs::vec_is vctrs::vec_cast) thus stick vctrs type conversion rules.","code":""},{"path":"https://lj-jenkins.github.io/restrictr_test/reference/cast_if_not.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Check if objects are of a specific type and cast them if not — cast_if_not","text":"","code":"cast_if_not(   ...,   .lossy = FALSE,   .env = caller_env(),   .error_call = caller_env() )"},{"path":"https://lj-jenkins.github.io/restrictr_test/reference/cast_if_not.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Check if objects are of a specific type and cast them if not — cast_if_not","text":"... number named R expressions, form : name_of_obj_to_cast = obj_of_type_to_cast_to .lossy whether allow lossy casting. .env environment use evaluation casting expressions & assignment casted variables. global environment. .error_call call environment use error (passed rlang::abort).","code":""},{"path":"https://lj-jenkins.github.io/restrictr_test/reference/cast_if_not.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Check if objects are of a specific type and cast them if not — cast_if_not","text":"","code":"# Will not alter the global environment so most examples here are wrapped with local(). x <- 1L cast_if_not(x = integer()) |> try() # => Error: Argument `call` cannot be the global environment.  local({   x <- 1L   cast_if_not(x = double())   class(x) }) #> [1] \"numeric\"  local({   x <- 1.5   cast_if_not(x = integer()) |> try() }) #> Error in eval(quote({ : Caused by error in `cast_if_not()`: #> ℹ In argument: `x = integer()`. #> ! Can't convert from `x` <double> to <integer> due to loss of precision. #> • Locations: 1 # => Error : Can't convert from `x` <double> to <integer> due to loss of precision.  local({   x <- 1.5   cast_if_not(x = integer(), .lossy = TRUE)   cat(x, class(x), sep = \", \") }) #> 1, integer  # other objects can be used as the type to cast to, e.g.: local({   x <- 1L   y <- 2.3   cast_if_not(x = y)   class(x) }) #> [1] \"numeric\"  # cast_if_not works sequentially, so references to objects will be # after they have been evaluated: local({   x <- y <- 1L   cast_if_not(x = double(), y = x)   cat(class(x), class(y), sep = \", \") }) #> numeric, numeric  myfunc <- \\(x) {   cast_if_not(x = double())   class(x) } x <- 1L myfunc(x) # x is cast to double within the function #> [1] \"numeric\" class(x) # x is still an integer outside the function #> [1] \"integer\"  local({   x <- y <- z <- 1L   cast_if_not(x = double(), y = double(), z = double())   cat(class(x), class(y), class(z), sep = \", \") }) #> numeric, numeric, numeric  # the `.env` argument determines the expression and assignment environment: local({   x <- 1L   e <- new.env()   e$x <- 1L   cast_if_not(x = 1.5, .env = e)   cat(class(e$x), class(x), sep = \", \") }) #> numeric, integer  # names (lhs) are checked to be in the `.env` environment, # throwing an error if not found: local({   x <- 1L   e <- new.env()   cast_if_not(x = 1.5, .env = e) |> try() }) #> Error in eval(quote({ : Caused by error in `cast_if_not()`. #> ! Object `x` is not found in the `.env` environment specified. # => Error: Objects `x` are not found in the `.env` environment specified.  # for expressions (rhs), the `.env` argument is preferentially chosen, but if not found # then the normal R scoping rules apply: local({   x <- 1.5   e <- new.env()   e$z <- 1L   cast_if_not(z = x, .env = e)   cat(class(e$z)) }) #> numeric"},{"path":"https://lj-jenkins.github.io/restrictr_test/reference/recycle_if_not.html","id":null,"dir":"Reference","previous_headings":"","what":"Check if objects are of a specific size and recycle them if not — recycle_if_not","title":"Check if objects are of a specific size and recycle them if not — recycle_if_not","text":"named expressions ... specified size, object attempts recycled size specified expression. Expressions evaluated variables assigned environment specified .env argument. checking size recycling vctrs package (using vctrs::vec_size vctrs::vec_recycle) thus stick vctrs recycling rules.","code":""},{"path":"https://lj-jenkins.github.io/restrictr_test/reference/recycle_if_not.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Check if objects are of a specific size and recycle them if not — recycle_if_not","text":"","code":"recycle_if_not(..., .env = caller_env(), .error_call = caller_env())"},{"path":"https://lj-jenkins.github.io/restrictr_test/reference/recycle_if_not.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Check if objects are of a specific size and recycle them if not — recycle_if_not","text":"... number named R expressions, form : name_of_obj_to_cast = size_to_cast_to .env environment use evaluation recycling expressions & assignment recycled variables. global environment. .error_call call environment use error (passed rlang::abort).","code":""},{"path":"https://lj-jenkins.github.io/restrictr_test/reference/recycle_if_not.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Check if objects are of a specific size and recycle them if not — recycle_if_not","text":"","code":"# Will not alter the global environment so most examples here are wrapped with local(). x <- 1 recycle_if_not(x = 1) |> try() # => Error: Argument `call` cannot be the global environment.  local({   x <- 1   recycle_if_not(x = 3)   x }) #> [1] 1 1 1  local({   x <- rep(1, 4)   recycle_if_not(x = 1) |> try() }) #> Error in eval(quote({ :  #>   Caused by error in `recycle_if_not()`: #> ℹ In argument: `x = 1`. #> ! Can't recycle `x` (size 4) to size 1. # => Error : Can't recycle `x` (size 4) to size 1.  local({   x <- 1L   y <- 2.3   recycle_if_not(x = 3, y = 2)   cat(x, y, sep = \", \") }) #> 1, 1, 1, 2.3, 2.3  # beware when using other objects as the size argument, e.g.: local({   x <- 1L   y <- c(1, 1, 1)   recycle_if_not(x = y) |> try() }) #> Error in eval(quote({ :  #>   Caused by error in `recycle_if_not()`: #> ℹ In argument: `x = y`. #> Size argument is not is not a scalar integerish value: length `3` given. # => Error : Size argument for `x` is not a scalar integerish value: # object length `3` of class <numeric>.  # when using other objects, call vctrs::vec_size() on them first: local({   x <- 1L   y <- c(1, 1, 1)   recycle_if_not(x = vctrs::vec_size(y))   x }) #> [1] 1 1 1  # recycle_if_not works sequentially, so references to objects will # be after they have been evaluated: local({   x <- y <- 1   recycle_if_not(x = 3, y = vctrs::vec_size(x))   cat(length(x), length(y), sep = \", \") }) #> 3, 3  myfunc <- \\(x) {   recycle_if_not(x = 3)   x } x <- 1L myfunc(x) # x is recycled to length 3 within the function #> [1] 1 1 1 x # x is still scalar outside the function #> [1] 1  local({   x <- 1   y <- 2   z <- 3   recycle_if_not(x = 2, y = 3, z = 4)   cat(x, y, z, sep = \", \") }) #> 1, 1, 2, 2, 2, 3, 3, 3, 3  # the `.env` argument determines the expression and assignment environment: local({   x <- 1   e <- new.env()   e$x <- 1   recycle_if_not(x = 3, .env = e)   cat(length(e$x), length(x), sep = \", \") }) #> 3, 1  # names (lhs) are checked to be in the `.env` environment, # throwing an error if not found: local({   x <- 1   e <- new.env()   recycle_if_not(x = 3, .env = e) |> try() }) #> Error in eval(quote({ :  #>   Caused by error in `recycle_if_not()`. #> ! Object `x` is not found in the `.env` environment specified. # Error: Objects `x` are not found in the `.env` environment specified.  # for expressions (rhs), the `.env` argument is preferentially chosen, # but if not found then the normal R scoping rules apply: local({   x <- 3   e <- new.env()   e$z <- 1   recycle_if_not(z = x, .env = e)   cat(e$z) }) #> 1 1 1"},{"path":"https://lj-jenkins.github.io/restrictr_test/reference/restrict.html","id":null,"dir":"Reference","previous_headings":"","what":"Restrict arguments to a specific type/size and test adherence to validation functions/formulas. — restrict","title":"Restrict arguments to a specific type/size and test adherence to validation functions/formulas. — restrict","text":"function takes number named expressions referring objects given environment, checking possibly coercing specified type /size, also checking number validation functions/formulas. Using function keywords validate, cast, lossy_cast, recycle, coerce within expressions allows different behaviours: validate: checks object specified type/size adheres validations, throwing error . cast: differs validate checking object specified type, attempts cast type (throwing error possible). lossy_cast: differs cast allowing lossy casting (e.g. double integer). recycle: differs validate checking object specified size, attempts recycle size (throwing error possible). coerce: differs validate checking type size, attempting cast /recycle type/size (throwing error possible). Casting lossy default can made lossy adding lossy = TRUE within coerce() call.","code":""},{"path":"https://lj-jenkins.github.io/restrictr_test/reference/restrict.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Restrict arguments to a specific type/size and test adherence to validation functions/formulas. — restrict","text":"","code":"restrict(..., .env = caller_env(), .error_call = caller_env())"},{"path":"https://lj-jenkins.github.io/restrictr_test/reference/restrict.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Restrict arguments to a specific type/size and test adherence to validation functions/formulas. — restrict","text":"... number named R expressions, names referring objects environment specified .env argument, expressions built using functions: validate(), cast(), lossy_cast(), recycle(), coerce(). .env environment use evaluation expressions & (possible) assignment variables. global environment. .error_call call environment use error (passed rlang::abort).","code":""},{"path":"https://lj-jenkins.github.io/restrictr_test/reference/restrict.html","id":"details","dir":"Reference","previous_headings":"","what":"Details","title":"Restrict arguments to a specific type/size and test adherence to validation functions/formulas. — restrict","text":"functions accept named arguments type, size mask (lossy also accepted within coerce()): type: R object desired type (e.g. integer(), double(), character(), list()). type checking casting done using vctrs package (using vctrs::vec_is vctrs::vec_cast) thus stick vctrs type conversion rules. size: scalar integerish value specifying desired size. size checking recycling done using vctrs package (using vctrs::vec_size vctrs::vec_recycle) thus stick vctrs recycling rules. mask: optional data frame list use data mask evaluations. Expressions evaluated using rlang::eval_tidy data argument set mask env argument set environment specified .env argument restrict(). mask must present within environment. na_rm: TRUE, NA values removed logical vectors validations evaluating (default FALSE). inputs unnamed validations: either expressions formulas (evaluate logical). restrict first evaluates type, size, validations. change prior expression reflected subsequent expressions, .e. object cast new type new type used size check validations. wish use vctrs type/size checking, instead give validations functions ~ .integer(.x). However, validate, cast recycle. restrict designed checking numerous objects, smaller number objects check see abort_if_not, cast_if_not, recycle_if_not, schema, schema_cast schema_recycle functions.","code":""},{"path":"https://lj-jenkins.github.io/restrictr_test/reference/restrict.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Restrict arguments to a specific type/size and test adherence to validation functions/formulas. — restrict","text":"","code":"# Will not alter the global environment so most examples here are wrapped with local(). x <- 1L restrict(x = validate(type = integer())) |> try() # => Error : Argument `.env` cannot be the global environment.  local({   x <- 1L   restrict(x = coerce(type = double(), size = 3))   cat(class(x), length(x), sep = \", \") }) #> numeric, 3  local({   x <- 1.5   restrict(x = cast(type = integer())) |> try() }) #> Error in eval(quote({ : Caused by error in `restrict()`: #> ℹ In argument: `x`. #> ! Can't convert from `x` <double> to <integer> due to loss of precision. #> • Locations: 1 # => Error : Can't convert from `x` <double> to <integer> due to loss of precision.  local({   x <- 1.5   restrict(x = lossy_cast(type = integer()))   cat(x, class(x), sep = \", \")    # or    x <- 1.5   restrict(x = coerce(type = integer(), lossy = TRUE))   cat(x, class(x), sep = \", \") }) #> 1, integer1, integer  # other objects can be used as the type to cast to or size to recycle to, e.g.: local({   x <- 1L   y <- 2.3   z <- 3L   restrict(x = coerce(type = y, size = z))   cat(class(x), length(x), sep = \", \") }) #> numeric, 3  # restrict works sequentially, so references to objects will be # after they have been evaluated: local({   x <- y <- 1L   restrict(     x = cast(type = double()),     y = cast(type = x)   )   cat(class(x), class(y), sep = \", \") }) #> numeric, numeric  # numerous validations can be given and type and size checking can be done # within if base R checking is preferred: local({   x <- 1L   restrict(     x = validate(       ~ is.integer(.x),       ~ length(.x) == 1,       \\(y) all(y > 0),       \\(z) !is.character(z)     )   ) })  # the `.env` argument determines the expression and assignment environment: local({   x <- 1L   e <- new.env()   e$x <- 1L   restrict(x = cast(type = 1.5), .env = e)   cat(class(e$x), class(x), sep = \", \") }) #> numeric, integer  # names (lhs) are checked to be in the `.env` environment, throwing an error if not found: local({   x <- 1L   e <- new.env()   restrict(x = cast(type = 1.5), .env = e) |> try() }) #> Error in eval(quote({ : Caused by error in `restrict()`: #> ℹ In argument: `x`. #> Object `x` is not found in the `.env` environment specified. # => Error: Objects `x` are not found in the `.env` environment specified.  # for expressions (rhs), the `.env` argument is preferentially chosen, but if not found # then the normal R scoping rules apply: local({   x <- 1.5   e <- new.env()   e$z <- 1L   restrict(x = cast(type = x), .env = e) |> try()   cat(class(e$z)) }) #> Error in eval(quote({ : Caused by error in `restrict()`: #> ℹ In argument: `x`. #> Object `x` is not found in the `.env` environment specified. #> integer"},{"path":"https://lj-jenkins.github.io/restrictr_test/reference/schema.html","id":null,"dir":"Reference","previous_headings":"","what":"Ensure data.frame/list elements conform to a given schema — schema","title":"Ensure data.frame/list elements conform to a given schema — schema","text":"data-masked expressions ... TRUE, rlang::abort called first expression () TRUE. .names .size arguments can used check given names size data.frame/list. checking size vctrs package (using vctrs::vec_size) thus applies vctrs size rules.","code":""},{"path":"https://lj-jenkins.github.io/restrictr_test/reference/schema.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Ensure data.frame/list elements conform to a given schema — schema","text":"","code":"schema(.data, ...)  # S3 method for class 'data.frame' schema(   .data,   ...,   .names = NULL,   .size = NULL,   .message = NULL,   .na_rm = FALSE,   .error_call = caller_env() )  # S3 method for class 'list' schema(   .data,   ...,   .names = NULL,   .size = NULL,   .message = NULL,   .na_rm = FALSE,   .error_call = caller_env() )"},{"path":"https://lj-jenkins.github.io/restrictr_test/reference/schema.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Ensure data.frame/list elements conform to a given schema — schema","text":".data data.frame list check schema . ... number R expressions evaluated using .data data-mask, evaluate (logical vector ) TRUE error occur. .names optional character vector names must present data.frame/list. .size optional scalar integerish value size data.frame/list must . .message single default error message non-named expressions. .na_rm TRUE, NA values removed logical vectors (default FALSE) .error_call call environment use error (passed rlang::abort).","code":""},{"path":"https://lj-jenkins.github.io/restrictr_test/reference/schema.html","id":"details","dir":"Reference","previous_headings":"","what":"Details","title":"Ensure data.frame/list elements conform to a given schema — schema","text":"schema_cast schema_recycle versions schema() attempt coerce data desired schema.","code":""},{"path":"https://lj-jenkins.github.io/restrictr_test/reference/schema.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Ensure data.frame/list elements conform to a given schema — schema","text":"","code":"# NB: Some of these examples are expected to produce an error. To #     prevent them from terminating a run with example() they are #     piped into a call to try().  li <- list(x = 1, y = \"hi\", z = \\(x) x > 1) li |>   schema(x == 1, is.character(y), is.function(z)) # all TRUE  li |>   schema(x == 1, is.numeric(y)) |>   try() #> Error in eval(expr, envir) : Caused by error in `schema()`: #> ℹ In argument: `is.numeric(y)` for data mask `li`. #> ! Returned `FALSE`. # => Error: Argument `is.numeric(y)` for data mask `.data` returned `FALSE`.  li |>   schema(length(x)) |>   try() #> Error in eval(expr, envir) : Caused by error in `schema()`: #> ℹ In argument: `length(x)` for data mask `li`. #> ! Returned <integer>, not <logical>. # => Error: Expression `length(x)` for object `.data` must evaluate to class # <logical> not <integer>. # even when if(1) \"ok\" works  # The default error message can be overridden to be more informative: df <- data.frame(a = 1L:3L, b = c(\"x\", \"y\", \"z\")) df |>   schema(\"a must be double\" = is.double(a)) |>   try() #> Error in eval(expr, envir) : Caused by error in `schema()`: #> ℹ In argument: `is.double(a)` for data mask `df`. #> ! a must be double # => Error: a must be double  # Alternatively, one error message can be used for all expressions: df |>   schema(     is.integer(a),     !grepl(\"x\", b),     .message = \"a must be integer and b cannot contain 'x'.\"   ) |>   try() #> Error in eval(expr, envir) : Caused by error in `schema()`: #> ℹ In argument: `!grepl(\"x\", b)` for data mask `df`. #> ! a must be integer and b cannot contain 'x'. # => Error: a must be integer and b cannot contain 'x'.  # injection and glue can be used to supply expressions, names, and messages: x <- \"my error\" schema(df, \"{x}\" = FALSE) |> try() #> Error in eval(expr, envir) : Caused by error in `schema()`: #> ℹ In argument: `FALSE` for data mask `df`. #> ! my error # => Error: my error y <- FALSE schema(df, {{ x }} := !!y) |> try() #> Error in eval(expr, envir) : Caused by error in `schema()`: #> ℹ In argument: `FALSE` for data mask `df`. #> ! my error # => Error: my error schema(df, !!x := !is.character(b)) |> try() #> Error in eval(expr, envir) : Caused by error in `schema()`: #> ℹ In argument: `!is.character(b)` for data mask `df`. #> ! my error # => Error: my error x <- list(\"my error\" = FALSE) schema(df, !!!x) |> try() #> Error in eval(expr, envir) : Caused by error in `schema()`: #> ℹ In argument: `FALSE` for data mask `df`. #> ! my error # => Error: my error"},{"path":"https://lj-jenkins.github.io/restrictr_test/reference/schema_cast.html","id":null,"dir":"Reference","previous_headings":"","what":"Ensure data.frame/list elements are of a specific type and cast them if not — schema_cast","title":"Ensure data.frame/list elements are of a specific type and cast them if not — schema_cast","text":"data-masked named expressions ... type, object attempts cast type specified expression. .names .size arguments can used check given names size data.frame/list. checking type type conversion vctrs package (using vctrs::vec_is vctrs::vec_cast) thus stick vctrs type conversion rules. checking size also vctrs (using vctrs::vec_size) thus applies vctrs size rules.","code":""},{"path":"https://lj-jenkins.github.io/restrictr_test/reference/schema_cast.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Ensure data.frame/list elements are of a specific type and cast them if not — schema_cast","text":"","code":"schema_cast(.data, ...)  # S3 method for class 'data.frame' schema_cast(   .data,   ...,   .lossy = FALSE,   .names = NULL,   .size = NULL,   .error_call = caller_env() )  # S3 method for class 'list' schema_cast(   .data,   ...,   .lossy = FALSE,   .names = NULL,   .size = NULL,   .error_call = caller_env() )"},{"path":"https://lj-jenkins.github.io/restrictr_test/reference/schema_cast.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Ensure data.frame/list elements are of a specific type and cast them if not — schema_cast","text":".data data.frame list check types schema . ... number data-masking name-value pairs evaluated using .data data-mask. follow format name = expected_type(), e.g, var_x = integer() var_x = var_y. .lossy logical, TRUE allow lossy casts. .names optional character vector names must present data.frame/list. .size optional scalar integerish value size data.frame/list must . .error_call call environment use error (passed rlang::abort).","code":""},{"path":"https://lj-jenkins.github.io/restrictr_test/reference/schema_cast.html","id":"details","dir":"Reference","previous_headings":"","what":"Details","title":"Ensure data.frame/list elements are of a specific type and cast them if not — schema_cast","text":"See also schema schema_recycle, well cast_if_not non-data-masked version casting.","code":""},{"path":"https://lj-jenkins.github.io/restrictr_test/reference/schema_cast.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Ensure data.frame/list elements are of a specific type and cast them if not — schema_cast","text":"","code":"# NB: Some of these examples are expected to produce an error. To #     prevent them from terminating a run with example() they are #     piped into a call to try().  li <- list(x = 1.1, y = \"hi\", z = 1L:2L) # input remains the same if types match li |>   schema_cast(x = double(), y = character(), z = integer()) |>   lapply(class) #> $x #> [1] \"numeric\" #>  #> $y #> [1] \"character\" #>  #> $z #> [1] \"integer\" #>   li |>   schema_cast(y = numeric()) |>   try() #> Error in eval(expr, envir) :  #>   Caused by error in `schema_cast()`: #> ℹ In argument: `y = numeric()` for data mask `li`. #> ! Can't convert `y` <character> to <double>. # => Error: Can't convert `y` <character> to <double>.  li |>   schema_cast(x = z) |>   try() #> Error in eval(expr, envir) :  #>   Caused by error in `schema_cast()`: #> ℹ In argument: `x = z` for data mask `li`. #> ! Can't convert from `x` <double> to <integer> due to loss of precision. #> • Locations: 1 # => Error: Can't convert from `x` <double> to <integer> due to loss of precision.  # with lossy casting li |>   schema_cast(x = z, .lossy = TRUE) |>   lapply(class) #> $x #> [1] \"integer\" #>  #> $y #> [1] \"character\" #>  #> $z #> [1] \"integer\" #>   # schema_cast works sequentially with quosures, so references to objects will be # after they have been evaluated: li$a <- 1L li |>   schema_cast(z = x, a = z) |>   lapply(class) #> $x #> [1] \"numeric\" #>  #> $y #> [1] \"character\" #>  #> $z #> [1] \"numeric\" #>  #> $a #> [1] \"numeric\" #>   li |>   schema_cast(x = numeric(), .size = 5) |>   try() #> Error in eval(expr, envir) :  #>   Caused by error in `schema_cast()`. #> ! Object `li` is of vctrs size `4`, not `5`. # => Error: Object `li` must have vctrs size `5`, not `4`.  li |>   schema_cast(x = numeric(), .names = c(\"x\", \"p\")) |>   try() #> Error in eval(expr, envir) :  #>   Caused by error in `schema_cast()`. #> ! Named element `p` not found in data mask `li`. # => Error: Names `p` not found in `li`.  # injection and glue can be used to supply expressions, names, and messages: li <- list(x = 1L, z = 5.5) x_name <- \"x\" schema_cast(li, !!x_name := z) |>   lapply(class) #> $x #> [1] \"numeric\" #>  #> $z #> [1] \"numeric\" #>  xg_name <- \"{x_name}\" schema_cast(li, {{ xg_name }} := character()) |> try() #> Error in eval(expr, envir) :  #>   Caused by error in `schema_cast()`: #> ℹ In argument: `x = character()` for data mask `li`. #> ! Can't convert `x` <integer> to <character>. # => Error: Can't convert `x` <integer> to <character>."},{"path":"https://lj-jenkins.github.io/restrictr_test/reference/schema_recycle.html","id":null,"dir":"Reference","previous_headings":"","what":"Ensure list elements are of a specific size and recycle them if not — schema_recycle","title":"Ensure list elements are of a specific size and recycle them if not — schema_recycle","text":"data-masked named expressions ... specified size, object attempts recycled size specified expression. .names .size arguments can used check given names size list. checking size recycling vctrs package (using vctrs::vec_size vctrs::vec_recycle) thus apply vctrs recycling rules.","code":""},{"path":"https://lj-jenkins.github.io/restrictr_test/reference/schema_recycle.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Ensure list elements are of a specific size and recycle them if not — schema_recycle","text":"","code":"schema_recycle(.data, ...)  # S3 method for class 'list' schema_recycle(   .data,   ...,   .names = NULL,   .size = NULL,   .error_call = caller_env() )"},{"path":"https://lj-jenkins.github.io/restrictr_test/reference/schema_recycle.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Ensure list elements are of a specific size and recycle them if not — schema_recycle","text":".data list check lengths schema . ... number data-masking name-value pairs evaluated using .data data-mask. follow format name = expected_size, e.g, var_x = 10L var_x = var_y. .names optional character vector names must present data.frame/list. .size optional scalar integerish value size data.frame/list must . .error_call call environment use error (passed rlang::abort).","code":""},{"path":"https://lj-jenkins.github.io/restrictr_test/reference/schema_recycle.html","id":"details","dir":"Reference","previous_headings":"","what":"Details","title":"Ensure list elements are of a specific size and recycle them if not — schema_recycle","text":"See also schema schema_recycle, well cast_if_not non-data-masked version casting.","code":""},{"path":"https://lj-jenkins.github.io/restrictr_test/reference/schema_recycle.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Ensure list elements are of a specific size and recycle them if not — schema_recycle","text":"","code":"# NB: Some of these examples are expected to produce an error. To #     prevent them from terminating a run with example() they are #     piped into a call to try().  li <- list(x = 1, y = \"hi\", z = 1:2) # li$x and li$y are recycled. li |>   schema_recycle(x = 5, y = 3) #> $x #> [1] 1 1 1 1 1 #>  #> $y #> [1] \"hi\" \"hi\" \"hi\" #>  #> $z #> [1] 1 2 #>   li |>   schema_recycle(z = 5) |>   try() #> Error in eval(expr, envir) :  #>   Caused by error in `schema_recycle()`: #> ℹ In argument: `z = 5` for data mask `li`. #> ! Can't recycle `z` (size 2) to size 5. # => Error: Can't recycle `z` (size 2) to size 5.  li |>   schema_recycle(x = \"hi\") |>   try() #> Error in eval(expr, envir) :  #>   Caused by error in `schema_recycle()`: #> ℹ In argument: `x = \"hi\"` for data mask `li`. #> Size argument is not <numeric>: <character> given. # => Size argument for `z` is not numeric: class <character>.  # schema_recycle works sequentially with quosures, so references to objects will # be after they have been evaluated: li |>   schema_recycle(x = vctrs::vec_size(z), y = vctrs::vec_size(x)) #> $x #> [1] 1 1 #>  #> $y #> [1] \"hi\" \"hi\" #>  #> $z #> [1] 1 2 #>   li |>   schema_recycle(x = 1, .size = 5) |>   try() #> Error in eval(expr, envir) :  #>   Caused by error in `schema_recycle()`. #> ! Object `li` is of vctrs size `3`, not `5`. # => Error: Object `li` must have vctrs size `5`, not `3`.  li |>   schema_recycle(x = 1, .names = c(\"x\", \"p\")) |>   try() #> Error in eval(expr, envir) :  #>   Caused by error in `schema_recycle()`. #> ! Named element `p` not found in data mask `li`. # => Error: Names `p` not found in `li`.  # injection and glue can be used to supply expressions, names, and messages: li <- list(x = 1, z = 5) x_name <- \"x\" schema_recycle(li, !!x_name := z) #> $x #> [1] 1 1 1 1 1 #>  #> $z #> [1] 5 #>  li$x <- 1:2 xg_name <- \"{x_name}\" schema_recycle(li, {{ xg_name }} := 10) |> try() #> Error in eval(expr, envir) :  #>   Caused by error in `schema_recycle()`: #> ℹ In argument: `x = 10` for data mask `li`. #> ! Can't recycle `x` (size 2) to size 10. # => Error: Can't recycle `x` (size 2) to size 10."}]
