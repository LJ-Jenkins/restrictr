[{"path":"https://lj-jenkins.github.io/restrictr_test/LICENSE.html","id":null,"dir":"","previous_headings":"","what":"Apache License","title":"Apache License","text":"Version 2.0, January 2004 <http://www.apache.org/licenses/>","code":""},{"path":[]},{"path":"https://lj-jenkins.github.io/restrictr_test/LICENSE.html","id":"id_1-definitions","dir":"","previous_headings":"Terms and Conditions for use, reproduction, and distribution","what":"1. Definitions","title":"Apache License","text":"“License” shall mean terms conditions use, reproduction, distribution defined Sections 1 9 document. “Licensor” shall mean copyright owner entity authorized copyright owner granting License. “Legal Entity” shall mean union acting entity entities control, controlled , common control entity. purposes definition, “control” means () power, direct indirect, cause direction management entity, whether contract otherwise, (ii) ownership fifty percent (50%) outstanding shares, (iii) beneficial ownership entity. “” (“”) shall mean individual Legal Entity exercising permissions granted License. “Source” form shall mean preferred form making modifications, including limited software source code, documentation source, configuration files. “Object” form shall mean form resulting mechanical transformation translation Source form, including limited compiled object code, generated documentation, conversions media types. “Work” shall mean work authorship, whether Source Object form, made available License, indicated copyright notice included attached work (example provided Appendix ). “Derivative Works” shall mean work, whether Source Object form, based (derived ) Work editorial revisions, annotations, elaborations, modifications represent, whole, original work authorship. purposes License, Derivative Works shall include works remain separable , merely link (bind name) interfaces , Work Derivative Works thereof. “Contribution” shall mean work authorship, including original version Work modifications additions Work Derivative Works thereof, intentionally submitted Licensor inclusion Work copyright owner individual Legal Entity authorized submit behalf copyright owner. purposes definition, “submitted” means form electronic, verbal, written communication sent Licensor representatives, including limited communication electronic mailing lists, source code control systems, issue tracking systems managed , behalf , Licensor purpose discussing improving Work, excluding communication conspicuously marked otherwise designated writing copyright owner “Contribution.” “Contributor” shall mean Licensor individual Legal Entity behalf Contribution received Licensor subsequently incorporated within Work.","code":""},{"path":"https://lj-jenkins.github.io/restrictr_test/LICENSE.html","id":"id_2-grant-of-copyright-license","dir":"","previous_headings":"Terms and Conditions for use, reproduction, and distribution","what":"2. Grant of Copyright License","title":"Apache License","text":"Subject terms conditions License, Contributor hereby grants perpetual, worldwide, non-exclusive, -charge, royalty-free, irrevocable copyright license reproduce, prepare Derivative Works , publicly display, publicly perform, sublicense, distribute Work Derivative Works Source Object form.","code":""},{"path":"https://lj-jenkins.github.io/restrictr_test/LICENSE.html","id":"id_3-grant-of-patent-license","dir":"","previous_headings":"Terms and Conditions for use, reproduction, and distribution","what":"3. Grant of Patent License","title":"Apache License","text":"Subject terms conditions License, Contributor hereby grants perpetual, worldwide, non-exclusive, -charge, royalty-free, irrevocable (except stated section) patent license make, made, use, offer sell, sell, import, otherwise transfer Work, license applies patent claims licensable Contributor necessarily infringed Contribution(s) alone combination Contribution(s) Work Contribution(s) submitted. institute patent litigation entity (including cross-claim counterclaim lawsuit) alleging Work Contribution incorporated within Work constitutes direct contributory patent infringement, patent licenses granted License Work shall terminate date litigation filed.","code":""},{"path":"https://lj-jenkins.github.io/restrictr_test/LICENSE.html","id":"id_4-redistribution","dir":"","previous_headings":"Terms and Conditions for use, reproduction, and distribution","what":"4. Redistribution","title":"Apache License","text":"may reproduce distribute copies Work Derivative Works thereof medium, without modifications, Source Object form, provided meet following conditions: () must give recipients Work Derivative Works copy License; (b) must cause modified files carry prominent notices stating changed files; (c) must retain, Source form Derivative Works distribute, copyright, patent, trademark, attribution notices Source form Work, excluding notices pertain part Derivative Works; (d) Work includes “NOTICE” text file part distribution, Derivative Works distribute must include readable copy attribution notices contained within NOTICE file, excluding notices pertain part Derivative Works, least one following places: within NOTICE text file distributed part Derivative Works; within Source form documentation, provided along Derivative Works; , within display generated Derivative Works, wherever third-party notices normally appear. contents NOTICE file informational purposes modify License. may add attribution notices within Derivative Works distribute, alongside addendum NOTICE text Work, provided additional attribution notices construed modifying License. may add copyright statement modifications may provide additional different license terms conditions use, reproduction, distribution modifications, Derivative Works whole, provided use, reproduction, distribution Work otherwise complies conditions stated License.","code":""},{"path":"https://lj-jenkins.github.io/restrictr_test/LICENSE.html","id":"id_5-submission-of-contributions","dir":"","previous_headings":"Terms and Conditions for use, reproduction, and distribution","what":"5. Submission of Contributions","title":"Apache License","text":"Unless explicitly state otherwise, Contribution intentionally submitted inclusion Work Licensor shall terms conditions License, without additional terms conditions. Notwithstanding , nothing herein shall supersede modify terms separate license agreement may executed Licensor regarding Contributions.","code":""},{"path":"https://lj-jenkins.github.io/restrictr_test/LICENSE.html","id":"id_6-trademarks","dir":"","previous_headings":"Terms and Conditions for use, reproduction, and distribution","what":"6. Trademarks","title":"Apache License","text":"License grant permission use trade names, trademarks, service marks, product names Licensor, except required reasonable customary use describing origin Work reproducing content NOTICE file.","code":""},{"path":"https://lj-jenkins.github.io/restrictr_test/LICENSE.html","id":"id_7-disclaimer-of-warranty","dir":"","previous_headings":"Terms and Conditions for use, reproduction, and distribution","what":"7. Disclaimer of Warranty","title":"Apache License","text":"Unless required applicable law agreed writing, Licensor provides Work (Contributor provides Contributions) “” BASIS, WITHOUT WARRANTIES CONDITIONS KIND, either express implied, including, without limitation, warranties conditions TITLE, NON-INFRINGEMENT, MERCHANTABILITY, FITNESS PARTICULAR PURPOSE. solely responsible determining appropriateness using redistributing Work assume risks associated exercise permissions License.","code":""},{"path":"https://lj-jenkins.github.io/restrictr_test/LICENSE.html","id":"id_8-limitation-of-liability","dir":"","previous_headings":"Terms and Conditions for use, reproduction, and distribution","what":"8. Limitation of Liability","title":"Apache License","text":"event legal theory, whether tort (including negligence), contract, otherwise, unless required applicable law (deliberate grossly negligent acts) agreed writing, shall Contributor liable damages, including direct, indirect, special, incidental, consequential damages character arising result License use inability use Work (including limited damages loss goodwill, work stoppage, computer failure malfunction, commercial damages losses), even Contributor advised possibility damages.","code":""},{"path":"https://lj-jenkins.github.io/restrictr_test/LICENSE.html","id":"id_9-accepting-warranty-or-additional-liability","dir":"","previous_headings":"Terms and Conditions for use, reproduction, and distribution","what":"9. Accepting Warranty or Additional Liability","title":"Apache License","text":"redistributing Work Derivative Works thereof, may choose offer, charge fee , acceptance support, warranty, indemnity, liability obligations /rights consistent License. However, accepting obligations, may act behalf sole responsibility, behalf Contributor, agree indemnify, defend, hold Contributor harmless liability incurred , claims asserted , Contributor reason accepting warranty additional liability. END TERMS CONDITIONS","code":""},{"path":"https://lj-jenkins.github.io/restrictr_test/LICENSE.html","id":"appendix-how-to-apply-the-apache-license-to-your-work","dir":"","previous_headings":"","what":"APPENDIX: How to apply the Apache License to your work","title":"Apache License","text":"apply Apache License work, attach following boilerplate notice, fields enclosed brackets [] replaced identifying information. (Don’t include brackets!) text enclosed appropriate comment syntax file format. also recommend file class name description purpose included “printed page” copyright notice easier identification within third-party archives.","code":"Copyright 2025 Luke Jenkins  Licensed under the Apache License, Version 2.0 (the \"License\"); you may not use this file except in compliance with the License. You may obtain a copy of the License at    http://www.apache.org/licenses/LICENSE-2.0  Unless required by applicable law or agreed to in writing, software distributed under the License is distributed on an \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the License for the specific language governing permissions and limitations under the License."},{"path":"https://lj-jenkins.github.io/restrictr_test/authors.html","id":null,"dir":"","previous_headings":"","what":"Authors","title":"Authors and Citation","text":"Luke Jenkins. Author, maintainer.","code":""},{"path":"https://lj-jenkins.github.io/restrictr_test/authors.html","id":"citation","dir":"","previous_headings":"","what":"Citation","title":"Authors and Citation","text":"Jenkins L (2025). restrictr: Function Argument Validation Coercion. R package version 0.0.0.9000, https://lj-jenkins.github.io/restrictr/.","code":"@Manual{,   title = {restrictr: Function Argument Validation and Coercion},   author = {Luke Jenkins},   year = {2025},   note = {R package version 0.0.0.9000},   url = {https://lj-jenkins.github.io/restrictr/}, }"},{"path":"https://lj-jenkins.github.io/restrictr_test/index.html","id":"restrictr-","dir":"","previous_headings":"","what":"Function Argument Validation and Coercion","title":"Function Argument Validation and Coercion","text":"restrictr superseded favr. Please use favr instead restrictr. restrictr provides tools validation safe type coercion/recycling function arguments.","code":""},{"path":"https://lj-jenkins.github.io/restrictr_test/index.html","id":"overview","dir":"","previous_headings":"","what":"Overview","title":"Function Argument Validation and Coercion","text":"abort_if_not() general validation. cast_if_not() recycle_if_not() safe type casting recycling variables. schema() validation named elements data.frames/lists. schema_cast() schema_recycle() safe type casting recycling named elements data.frames/lists. enforce_schema() reapply attached schema functions. restrict() validation, safe type casting safe recycling variables named elements data.frames/lists.","code":""},{"path":"https://lj-jenkins.github.io/restrictr_test/index.html","id":"installation","dir":"","previous_headings":"","what":"Installation","title":"Function Argument Validation and Coercion","text":"can install development version restrictr GitHub :","code":"# install.packages(\"pak\") pak::pak(\"LJ-Jenkins/restrictr\")"},{"path":"https://lj-jenkins.github.io/restrictr_test/index.html","id":"examples","dir":"","previous_headings":"","what":"Examples","title":"Function Argument Validation and Coercion","text":"abort_if_not can used validations: cast_if_not recycle_if_not provide safe casting recycling vctrs. Variables provided left hand side expected type/size provided right. Assignment automatically done back environment specified (default caller_env()): schema, schema_cast schema_recycle provide functionality data-masked arguments data.frames/lists. size data.frame/list whether certain names present can also checked using .names .size arguments. altered data-mask object returned attached class with_schema used enforce_schema() reapply original schema call: restrict combines functionality multi-purpose tool. variables named elements within data.frames/lists can validated casted/recycled. keyword functions validate, cast, lossy_cast, recycle coerce determines whether type casting /recycling occurs. Validation functions can given, either form functions lambdas. Assignment occurs back environment specified (default caller_env()). contradictory example just show features:","code":"library(restrictr)  f <- \\(x, y) {   abort_if_not(     is.character(x),     \"`{x}` is too short!\" = nchar(x) > 5,     y$x == 1   ) }  f(1L, list(x = 1)) #> Error in glue_names(tf, eval_env = eval_env, error_call = .error_call, : could not find function \"glue_names\"  f(\"hi\", list(x = 1)) #> Error in glue_names(tf, eval_env = eval_env, error_call = .error_call, : could not find function \"glue_names\" f <- \\(x, y) {   cast_if_not(x = double())   recycle_if_not(y = x)    print(class(x))   print(length(y)) }  f(5L, 1) #> Error in glue_names(qs, eval_env = .env, error_call = .error_call, restrictr_fn = restrictr_fn): could not find function \"glue_names\"  f <- \\(x) {   cast_if_not(x = integer(), .lossy = TRUE)    print(x) }  f(1.5) #> Error in glue_names(qs, eval_env = .env, error_call = .error_call, restrictr_fn = restrictr_fn): could not find function \"glue_names\"  f(\"hi\") #> Error in glue_names(qs, eval_env = .env, error_call = .error_call, restrictr_fn = restrictr_fn): could not find function \"glue_names\" f <- \\(df) {   df |>     schema(x == 1) }  f(data.frame(x = 2)) #> Error in (function (cnd) : object 'j' not found  f <- \\(df) {   df <- df |>     schema_cast(x = double())    print(class(df$x)) }  f(data.frame(x = 1L)) #> Error in schema_cast(df, x = double()): could not find function \"schema_cast\"  # schema_recycle is only implemented for lists. f <- \\(li) {   li <- li |>     schema_recycle(x = 3, y = 5, z = vctrs::vec_size(x))    print(lengths(li)) }  f(list(x = 1, y = 1, z = 1)) #> Error in schema_recycle(li, x = 3, y = 5, z = vctrs::vec_size(x)): could not find function \"schema_recycle\"  # enforce_schema reapplies the original call. li <- list(x = 1, y = \"hi\") li_with_schema <- schema(li, x == 1, is.character(y)) li_with_schema$y <- 1  enforce_schema(li_with_schema) #> Error in if (lhs == \"\") rhs else lhs: argument is of length zero  df <- data.frame(x = 1:2) df_with_schema <- schema_cast(df, x = integer(), .lossy = TRUE) #> Error in schema_cast(df, x = integer(), .lossy = TRUE): could not find function \"schema_cast\" df_with_schema$x <- c(1.5, 2.5) #> Error: object 'df_with_schema' not found  enforce_schema(df_with_schema)$x #> Error: object 'df_with_schema' not found  li_with_schema <- schema_recycle(li, x = 2, y = 3) #> Error in schema_recycle(li, x = 2, y = 3): could not find function \"schema_recycle\" li_with_schema$y <- \"hi\"  enforce_schema(li_with_schema)$y #> [1] \"hi\" f <- \\(df, x) {   restrict(     df = validate(       type = data.frame(x = integer()),       size = 1,       ~ ncol(.x) == 1,       \\(.x) colnames(.x) == \"x\"     ),     x = cast(type = .env$x, mask = df),     x = coerce(type = integer(), size = df$x, lossy = TRUE)   )    cat(\"`df$x` casted to\", class(df$x), \"from the initial `x` class \\n\")   cat(\"`x` lossily casted to\", class(x), \"and recycled using value of `df$x` to length\", length(x)) }  f(data.frame(x = 3L), 1.5) #> Error in glue_names(rargs, eval_env = .env, error_call = .error_call, : could not find function \"glue_names\"  #-- vctrs type/size rules are for all `cast`, `recycle` and `coerce` calls within restrictr functions f <- \\(df) {   restrict(df = validate(type = data.frame(x = integer(), y = double()))) }  f(data.frame(x = 1L, y = \"hi\")) #> Error in glue_names(rargs, eval_env = .env, error_call = .error_call, : could not find function \"glue_names\"  f <- \\(x) {   restrict(x = recycle(size = 10)) }  f(1:5) #> Error in glue_names(rargs, eval_env = .env, error_call = .error_call, : could not find function \"glue_names\""},{"path":"https://lj-jenkins.github.io/restrictr_test/index.html","id":"notes","dir":"","previous_headings":"Examples","what":"Notes","title":"Function Argument Validation and Coercion","text":"restrictr restrict inspired MATLAB’s arguments block. restrictr functions clean-case errors. typical usage within functions, little impact. However, intend continue using variables associated environments, care taken. See following example:","code":"local({   x <- 1L   y <- 1L   cast_if_not(x = double(), y = character()) |> try()   cat(     \"Code has errored but `x` has still been casted to:\",     class(x), \"\\n\",     \"in the environment specified for the `cast_if_not` call.\"   ) }) #> Error in glue_names(qs, eval_env = .env, error_call = .error_call, restrictr_fn = restrictr_fn) :  #>   could not find function \"glue_names\" #> Code has errored but `x` has still been casted to: integer  #>  in the environment specified for the `cast_if_not` call."},{"path":"https://lj-jenkins.github.io/restrictr_test/reference/abort_if_not.html","id":null,"dir":"Reference","previous_headings":"","what":"Ensure the truth of R expressions — abort_if_not","title":"Ensure the truth of R expressions — abort_if_not","text":"expressions ... TRUE, rlang::abort called first expression () TRUE. replacement stopifnot utilises rlang, cli, glue.","code":""},{"path":"https://lj-jenkins.github.io/restrictr_test/reference/abort_if_not.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Ensure the truth of R expressions — abort_if_not","text":"","code":"abort_if_not(..., .na_rm = FALSE, .message = NULL, .error_call = caller_env())"},{"path":"https://lj-jenkins.github.io/restrictr_test/reference/abort_if_not.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Ensure the truth of R expressions — abort_if_not","text":"... number R expressions, evaluate (logical vector ) TRUE error occur. Positive numbers TRUE, even coerced TRUE inside () arithmetic computations R. expressions named, names used error message. Names support rlang injection glue interpreted string literals. .na_rm TRUE, NA values removed logical vectors evaluation. .message single default error message non-named expressions. Can glue string. .error_call call environment use error messages (passed rlang::abort).","code":""},{"path":"https://lj-jenkins.github.io/restrictr_test/reference/abort_if_not.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Ensure the truth of R expressions — abort_if_not","text":"NULL, called side effects .","code":""},{"path":"https://lj-jenkins.github.io/restrictr_test/reference/abort_if_not.html","id":"details","dir":"Reference","previous_headings":"","what":"Details","title":"Ensure the truth of R expressions — abort_if_not","text":"abort_if() opposite abort_if_not(), .e. expressions evaluate () FALSE error occur.","code":""},{"path":"https://lj-jenkins.github.io/restrictr_test/reference/abort_if_not.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Ensure the truth of R expressions — abort_if_not","text":"","code":"# NB: Some of these examples are expected to produce an error. To #     prevent them from terminating a run with example() they are #     piped into a call to try().  abort_if_not(1 == 1, all.equal(pi, 3.14159265), 1 < 2) # all TRUE  m <- matrix(c(1, 3, 3, 1), 2, 2) abort_if_not(m == t(m), diag(m) == rep(1, 2)) # all TRUE  abort_if_not(1) |> try() #> Error in eval(expr, envir) :  #>   Caused by error in `abort_if_not()`: #> ℹ In argument: `1`. #> ! Returned <numeric>, not <logical>. # Error: # Caused by error in `abort_if_not()`: # ℹ In argument: `1`. # ! Returned <integer>, not <logical>.  # A custom error message can be given for each expression: m[1, 2] <- 12 abort_if_not(\"m must be symmetric\" = m == t(m)) |> try() #> Error in eval(expr, envir) :  #>   Caused by error in `abort_if_not()`: #> ℹ In argument: `m == t(m)`. #> ! m must be symmetric # Error: # Caused by error in `abort_if_not()`: # ℹ In argument: `m == t(m)`. # ! m must be symmetric  # Alternatively, one error message can be used for all expressions: abort_if_not(   m == t(m),   diag(m) == rep(1, 2),   .message = \"m must be symmetric and have 1s on the diagonal.\" ) |> try() #> Error in eval(expr, envir) :  #>   Caused by error in `abort_if_not()`: #> ℹ In argument: `m == t(m)`. #> ! m must be symmetric and have 1s on the diagonal. # Error: # Caused by error in `abort_if_not()`: # ℹ In argument: `m == t(m)`. # ! m must be symmetric and have 1s on the diagonal.  # Option to remove NA values before checking: abort_if_not(c(TRUE, NA, TRUE), .na_rm = TRUE) # no error  # The `.error_call` argument can be used to specify where the error occurs, # by default this is the caller environment. myfunc <- function(x) abort_if_not(x) myfunc(FALSE) |> try() #> Error in myfunc(FALSE) :  #>   Caused by error in `abort_if_not()`: #> ℹ In argument: `x`. #> ! Returned `FALSE`. # Error in `myfunc()`: # Caused by error in `abort_if_not()`: # ℹ In argument: `x`. # ! Returned `FALSE`.  # abort_if() errors if any argument does not evaluate to (all) FALSE. abort_if(1 == 1) |> try() #> Error in eval(expr, envir) :  #>   Caused by error in `abort_if()`: #> ℹ In argument: `1 == 1`. #> ! Returned `TRUE`. # Error: # Caused by error in `abort_if()`: # ℹ In argument: `1 == 1`. # ! Returned `TRUE`.  # Injection and glue can be used: x <- \"my error\" abort_if_not(\"{x}\" = FALSE) |> try() #> Error in eval(expr, envir) :  #>   Caused by error in `abort_if_not()`: #> ℹ In argument: `FALSE`. #> ! my error abort_if_not({{ x }} := FALSE) |> try() #> Error in eval(expr, envir) :  #>   Caused by error in `abort_if_not()`: #> ℹ In argument: `FALSE`. #> ! my error abort_if_not(!!x := FALSE) |> try() #> Error in eval(expr, envir) :  #>   Caused by error in `abort_if_not()`: #> ℹ In argument: `FALSE`. #> ! my error abort_if_not(FALSE, .message = \"{x}\") |> try() #> Error in eval(expr, envir) :  #>   Caused by error in `abort_if_not()`: #> ℹ In argument: `FALSE`. #> ! my error # Error: # Caused by error in `abort_if_not()`: # ℹ In argument: `FALSE`. # ! my error x <- list(\"my bang-bang-bang error\" = FALSE) abort_if_not(!!!x) |> try() #> Error in eval(expr, envir) :  #>   Caused by error in `abort_if_not()`: #> ℹ In argument: `FALSE`. #> ! my bang-bang-bang error # Error: # Caused by error in `abort_if_not()`: # ℹ In argument: `FALSE`. # ! my bang-bang-bang error"},{"path":"https://lj-jenkins.github.io/restrictr_test/reference/cast_if_not.html","id":null,"dir":"Reference","previous_headings":"","what":"Check if objects are of a specific type and cast them if not — cast_if_not","title":"Check if objects are of a specific type and cast them if not — cast_if_not","text":"named expressions ... type, object specified name attempts cast type specified expression. Expressions evaluated objects assigned environment specified .env argument. checking type type conversion vctrs package (using vctrs::vec_is vctrs::vec_cast) thus stick vctrs type conversion rules.","code":""},{"path":"https://lj-jenkins.github.io/restrictr_test/reference/cast_if_not.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Check if objects are of a specific type and cast them if not — cast_if_not","text":"","code":"cast_if_not(   ...,   .lossy = FALSE,   .env = caller_env(),   .error_call = caller_env() )"},{"path":"https://lj-jenkins.github.io/restrictr_test/reference/cast_if_not.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Check if objects are of a specific type and cast them if not — cast_if_not","text":"... number named R expressions, form : name_of_object_to_cast = object_of_type_to_cast_to .lossy TRUE, lossy casting undertaken. .env environment use evaluation casting expressions assignment casted objects. global environment. .error_call call environment use error messages (passed rlang::abort).","code":""},{"path":"https://lj-jenkins.github.io/restrictr_test/reference/cast_if_not.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Check if objects are of a specific type and cast them if not — cast_if_not","text":"NULL, objects named ... changed .env environment specified.","code":""},{"path":"https://lj-jenkins.github.io/restrictr_test/reference/cast_if_not.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Check if objects are of a specific type and cast them if not — cast_if_not","text":"","code":"# NB: Will not alter the global environment so examples #     here are wrapped with local(). Some of these examples #     are also expected to produce an error so are piped to try().  x <- 1L cast_if_not(x = integer()) |> try() # Error: # Caused by error in `cast_if_not()`. # ! `env` must not be the global environment.  local({   x <- 1L # integer   cast_if_not(x = double())   class(x) }) #> [1] \"numeric\" # \"numeric\"  # By default, lossy casting is not allowed: local({   x <- c(1, 1.5)   cast_if_not(x = integer()) |> try() }) #> Error in eval(quote({ : Caused by error in `cast_if_not()`: #> ℹ In argument: `x = integer()`. #> ! Can't convert from `x` <double> to <integer> due to loss of precision. #> • Locations: 2 # Error: # Caused by error in `cast_if_not()`: # ℹ In argument: `x = integer()`. # ! Can't convert from `x` <double> to <integer> due to loss of precision. # • Locations: 2  # lossy casting can be enabled with the `.lossy` argument: local({   x <- c(1, 1.5)   cast_if_not(x = integer(), .lossy = TRUE)   class(x) }) #> [1] \"integer\" # \"integer\"  # Other objects can be used as the type to cast to, e.g.: local({   x <- 1L   y <- 2.3   cast_if_not(x = y)   class(x) }) #> [1] \"numeric\" # \"numeric\"  # cast_if_not() works sequentially, so references to objects will be # after they have been evaluated: local({   x <- y <- 1L   cast_if_not(x = double(), y = x)   cat(class(x), class(y), sep = \", \") }) #> numeric, numeric # numeric, numeric  myfunc <- \\(x) {   cast_if_not(x = double())   class(x) } x <- 1L myfunc(x) # x is cast to double within the function #> [1] \"numeric\" class(x) # x is still an integer outside the function #> [1] \"integer\"  # The `.env` argument determines the expression and assignment environment: local({   x <- 1L   e <- new.env()   e$x <- 1L   cast_if_not(x = 1.5, .env = e)   cat(     \"environment 'e'\", class(e$x), \"local environment\", class(x),     sep = \", \"   ) }) #> environment 'e', numeric, local environment, integer # environment 'e', numeric, local environment, integer  # Named objects (lhs) are checked to be in the `.env` environment, # throwing an error if not found: local({   x <- 1L   e <- new.env()   cast_if_not(x = 1.5, .env = e) |> try() }) #> Error in eval(quote({ : Caused by error in `cast_if_not()`. #> ! Object `x` is not found in the `.env` environment specified. # Error: # Caused by error in `cast_if_not()`. # ! Object `x` is not found in the `.env` environment specified.  # For expressions (rhs), the `.env` argument is preferentially chosen, # but if not found then the normal R scoping rules apply: local({   x <- 1.5   e <- new.env()   e$z <- 1L   cast_if_not(z = x, .env = e)   class(e$z) }) #> [1] \"numeric\" # \"numeric\"  # The `.error_call` argument can be used to specify where the error occurs, # by default this is the caller environment. myfunc <- function(x) cast_if_not(x = character()) myfunc(FALSE) |> try() #> Error in myfunc(FALSE) :  #>   Caused by error in `cast_if_not()`: #> ℹ In argument: `x = character()`. #> ! Can't convert `x` <logical> to <character>. # Error in `myfunc()`: # Caused by error in `cast_if_not()`: # ℹ In argument: `x = character()`. # ! Can't convert `x` <double> to <character>.  # Injection and glue can be used: local({   y <- 1L   x <- \"y\"   cast_if_not(\"{x}\" = double())   class(y) }) #> [1] \"numeric\" # \"numeric\" local({   y <- 1L   x <- list(y = double())   cast_if_not(!!!x)   class(y) }) #> [1] \"numeric\" # \"numeric\""},{"path":"https://lj-jenkins.github.io/restrictr_test/reference/enforce_schema.html","id":null,"dir":"Reference","previous_headings":"","what":"Enforce an attached schema — enforce_schema","title":"Enforce an attached schema — enforce_schema","text":"objects attached schema (schema, schema_cast, schema_recycle), enforce schema object.","code":""},{"path":"https://lj-jenkins.github.io/restrictr_test/reference/enforce_schema.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Enforce an attached schema — enforce_schema","text":"","code":"enforce_schema(.data, ...)  # S3 method for class 'with_schema' enforce_schema(   .data,   ...,   .error_call = caller_env(),   .darg = caller_arg(.data) )"},{"path":"https://lj-jenkins.github.io/restrictr_test/reference/enforce_schema.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Enforce an attached schema — enforce_schema","text":".data data.frame list containing attached schema (class with_schema). ... future extensions - leave empty. .error_call call environment use error messages (passed rlang::abort). .darg argument name .data use error messages.","code":""},{"path":"https://lj-jenkins.github.io/restrictr_test/reference/enforce_schema.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Enforce an attached schema — enforce_schema","text":"Object .data, change attached schema schema, named elements cast recycled desired type/size attached schema schema_cast schema_recycle respectively.","code":""},{"path":"https://lj-jenkins.github.io/restrictr_test/reference/enforce_schema.html","id":"details","dir":"Reference","previous_headings":"","what":"Details","title":"Enforce an attached schema — enforce_schema","text":"See schema, schema_cast schema_recycle creating attaching schema.","code":""},{"path":"https://lj-jenkins.github.io/restrictr_test/reference/enforce_schema.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Enforce an attached schema — enforce_schema","text":"","code":"# NB: Some of these examples are expected to produce an error. To #     prevent them from terminating a run with example() they are #     piped into a call to try().  li <- list(x = 1, y = \"hi\") li_with_schema <- schema(li, x == 1, is.character(y))  li_with_schema$y <- 1 enforce_schema(li_with_schema) |> try() #> Error in eval(expr, envir) :  #>   Caused by error in `enforce_schema()`: #> ℹ In argument: `is.character(y)` for data mask `li_with_schema`. #> ! Returned `FALSE`. # Error: # Caused by error in `enforce_schema()`: # ℹ In argument: `is.character(y)` for data mask `li_with_schema`. # ! Returned `FALSE`.  df <- data.frame(x = 1:2) df_with_schema <- schema_cast(df, x = integer(), .lossy = TRUE)  df_with_schema$x <- c(1.5, 2.5) enforce_schema(df_with_schema)$x #> [1] 1 2 # 1 2  li_with_schema <- schema_recycle(li, x = 2, y = 3) li_with_schema$y <- \"hi\" enforce_schema(li_with_schema)$y #> [1] \"hi\" \"hi\" \"hi\" # \"hi\" \"hi\" \"hi\"  # The `.error_call` argument can be used to specify where the error occurs, # by default this is the caller environment. myfunc <- function(.x) enforce_schema(.x) li_with_schema$x <- 1:3 myfunc(li_with_schema) |> try() #> Error in myfunc(li_with_schema) :  #>   Caused by error in `enforce_schema()`: #> ℹ In argument: `x = 2` for data mask `.x`. #> ! Can't recycle `x` (size 3) to size 2. # Error in `myfunc()`: # Caused by error in `enforce_schema()`: # ℹ In argument: `x = 2` for data mask `li`. # ! Can't recycle `x` (size 3) to size 2."},{"path":"https://lj-jenkins.github.io/restrictr_test/reference/recycle_if_not.html","id":null,"dir":"Reference","previous_headings":"","what":"Check if objects are of a specific size and recycle them if not — recycle_if_not","title":"Check if objects are of a specific size and recycle them if not — recycle_if_not","text":"named expressions ... specified size, object specified name attempts recycled size specified expression. Expressions evaluated objects assigned environment specified .env argument. checking size recycling vctrs package (using vctrs::vec_size vctrs::vec_recycle) thus stick vctrs recycling rules.","code":""},{"path":"https://lj-jenkins.github.io/restrictr_test/reference/recycle_if_not.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Check if objects are of a specific size and recycle them if not — recycle_if_not","text":"","code":"recycle_if_not(..., .env = caller_env(), .error_call = caller_env())"},{"path":"https://lj-jenkins.github.io/restrictr_test/reference/recycle_if_not.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Check if objects are of a specific size and recycle them if not — recycle_if_not","text":"... number named R expressions, form : name_of_object_to_recycle = size_to_recycle_to .env environment use evaluation recycling expressions assignment recycled objects. global environment. .error_call call environment use error messages (passed rlang::abort).","code":""},{"path":"https://lj-jenkins.github.io/restrictr_test/reference/recycle_if_not.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Check if objects are of a specific size and recycle them if not — recycle_if_not","text":"NULL, objects named ... changed .env environment specified.","code":""},{"path":"https://lj-jenkins.github.io/restrictr_test/reference/recycle_if_not.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Check if objects are of a specific size and recycle them if not — recycle_if_not","text":"","code":"# NB: Will not alter the global environment so examples #     here are wrapped with local(). Some of these examples #     are also expected to produce an error so are piped to try().  x <- 1 recycle_if_not(x = 1) |> try() # Error: # Caused by error in `recycle_if_not()`. # ! `env` must not be the global environment.  local({   x <- 1   recycle_if_not(x = 3)   length(x) }) #> [1] 3 # 3  # recycle_if_not() follows `vctrs` recycling rules: local({   x <- c(1, 1)   recycle_if_not(x = 6) |> try() }) #> Error in eval(quote({ :  #>   Caused by error in `recycle_if_not()`: #> ℹ In argument: `x = 6`. #> ! Can't recycle `x` (size 2) to size 6. # Error: # Caused by error in `recycle_if_not()`: # ℹ In argument: `x = 6`. # ! Can't recycle `x` (size 2) to size 6.  local({   x <- 1L   y <- 2.3   recycle_if_not(x = 3, y = 2)   cat(length(x), length(y), sep = \", \") }) #> 3, 2 # 3, 2  # Beware when using other objects as the size argument, e.g.: local({   x <- 1L   y <- c(1, 1, 1)   recycle_if_not(x = y) |> try() }) #> Error in eval(quote({ :  #>   Caused by error in `recycle_if_not()`: #> ℹ In argument: `x = y`. #> ! Size argument is length `3`, needs to be positive scalar integerish. # Error: # Caused by error in `recycle_if_not()`: # ℹ In argument: `x = y`. # ! Size argument is length `3`, needs to be scalar integerish.  # When using other objects, call vctrs::vec_size() on them first: local({   x <- 1L   y <- c(1, 1, 1)   recycle_if_not(x = vctrs::vec_size(y))   length(x) }) #> [1] 3 # 3  # recycle_if_not() works sequentially, so references to objects will # be after they have been evaluated: local({   x <- y <- 1   recycle_if_not(x = 3, y = vctrs::vec_size(x))   cat(length(x), length(y), sep = \", \") }) #> 3, 3 # 3, 3  myfunc <- \\(x) {   recycle_if_not(x = 3)   length(x) } x <- 1L myfunc(x) # x is recycled to length 3 within the function #> [1] 3 length(x) # x is still scalar outside the function #> [1] 1  # The `.env` argument determines the expression and assignment environment: local({   x <- 1   e <- new.env()   e$x <- 1   recycle_if_not(x = 3, .env = e)   cat(     \"environment 'e'\", length(e$x), \"local environment\", length(x),     sep = \", \"   ) }) #> environment 'e', 3, local environment, 1  # Named objects (lhs) are checked to be in the `.env` environment, # throwing an error if not found: local({   x <- 1   e <- new.env()   recycle_if_not(x = 3, .env = e) |> try() }) #> Error in eval(quote({ :  #>   Caused by error in `recycle_if_not()`. #> ! Object `x` is not found in the `.env` environment specified. # Error: # Caused by error in `recycle_if_not()`. # ! Object `x` is not found in the `.env` environment specified.  # For expressions (rhs), the `.env` argument is preferentially chosen, # but if not found then the normal R scoping rules apply: local({   x <- 3   e <- new.env()   e$z <- 1   recycle_if_not(z = x, .env = e)   length(e$z) }) #> [1] 3 # 3  # The `.error_call` argument can be used to specify where the error occurs, # by default this is the caller environment. myfunc <- function(x) recycle_if_not(x = -5) myfunc(1) |> try() #> Error in myfunc(1) : Caused by error in `recycle_if_not()`: #> ℹ In argument: `x = -5`. #> ! Size argument is `-5`, needs to be positive scalar integerish. # Error in `myfunc()`: # Caused by error in `recycle_if_not()`: # ℹ In argument: `x = -5`. # ! Size argument is `-5`, needs to be positive scalar integerish.  #' # Injection and glue can be used: local({   y <- 1L   x <- \"y\"   recycle_if_not(\"{x}\" = 5)   length(y) }) #> [1] 5 # 5 local({   y <- 1L   x <- list(y = 5)   recycle_if_not(!!!x)   length(y) }) #> [1] 5 # 5"},{"path":"https://lj-jenkins.github.io/restrictr_test/reference/restrict.html","id":null,"dir":"Reference","previous_headings":"","what":"Restrict arguments to a specific type/size and test adherence to validation functions/formulas. — restrict","title":"Restrict arguments to a specific type/size and test adherence to validation functions/formulas. — restrict","text":"function takes number named expressions referring objects environment specified .env argument, checking possibly coercing specified type /size, also checking number validation functions/formulas. Using function keywords validate, cast, lossy_cast, recycle, coerce within expressions allows different behaviours: validate: checks object specified type/size adheres validations, throwing error . cast: differs validate attempting cast object specified type. lossy_cast: differs cast allowing lossy casting. recycle: differs validate attempting recycle object specified size. coerce: differs validate attempting cast /recycle object specified type /size. Casting lossy default can made lossy adding lossy = TRUE within coerce() call.","code":""},{"path":"https://lj-jenkins.github.io/restrictr_test/reference/restrict.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Restrict arguments to a specific type/size and test adherence to validation functions/formulas. — restrict","text":"","code":"restrict(..., .env = caller_env(), .error_call = caller_env())"},{"path":"https://lj-jenkins.github.io/restrictr_test/reference/restrict.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Restrict arguments to a specific type/size and test adherence to validation functions/formulas. — restrict","text":"... number named R expressions, names referring objects environment specified .env argument, expressions built using functions: validate(), cast(), lossy_cast(), recycle(), coerce(). .env environment use evaluation casting/recycling/validation expressions assignment altered objects. global environment. .error_call call environment use error messages (passed rlang::abort).","code":""},{"path":"https://lj-jenkins.github.io/restrictr_test/reference/restrict.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Restrict arguments to a specific type/size and test adherence to validation functions/formulas. — restrict","text":"NULL, objects named ... changed .env environment specified.","code":""},{"path":"https://lj-jenkins.github.io/restrictr_test/reference/restrict.html","id":"details","dir":"Reference","previous_headings":"","what":"Details","title":"Restrict arguments to a specific type/size and test adherence to validation functions/formulas. — restrict","text":"functions accept named arguments type, size mask (lossy also accepted within coerce()): type: R object desired type (e.g. integer(), double(), character(), list()). type checking casting done using vctrs package (using vctrs::vec_is vctrs::vec_cast) thus stick vctrs type conversion rules. size: positive scalar integerish value specifying desired size. size checking recycling done using vctrs package (using vctrs::vec_size vctrs::vec_recycle) thus stick vctrs recycling rules. mask: name optional data frame list (found within .env environment) use data mask evaluations. na_rm: TRUE, NA values removed logical vectors evaluation. inputs validation functions formulas evaluate logical. restrict first evaluates type, size, validations. change prior expression reflected subsequent expressions, .e. object cast new type new type used size check validations. wish use vctrs type/size checking, instead give validations ~ .integer(.x) ~ length(.x) == 1. However, validate, cast recycle. restrict designed checking numerous objects, smaller number objects check see abort_if_not, cast_if_not,recycle_if_not, schema, schema_cast schema_recycle.","code":""},{"path":"https://lj-jenkins.github.io/restrictr_test/reference/restrict.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Restrict arguments to a specific type/size and test adherence to validation functions/formulas. — restrict","text":"","code":"# NB: Will not alter the global environment so examples #     here are wrapped with local(). Some of these examples #     are also expected to produce an error so are piped to try().  x <- 1L restrict(x = validate(type = integer())) |> try() # Error: # Caused by error in `recycle_if_not()`. # ! `env` must not be the global environment.  # Functions used within restrict() determine behaviour: local({   x <- 1L   # validate() for validations only.   restrict(x = validate(type = integer(), size = 1, ~ .x < 5))    # cast() for validations and type casting (lossy_cast() for lossy casting).   restrict(x = cast(type = double(), size = 1, ~ .x < 5))   class(x) |> print()    # recycle() for validations and size recycling.   restrict(x = recycle(type = double(), size = 3, ~ .x < 5))   length(x) |> print()    # coerce() for validations, type casting and size recycling.   x <- 1L   restrict(x = coerce(type = double(), size = 3, ~ .x < 5))   cat(class(x), length(x), sep = \", \") }) #> [1] \"numeric\" #> [1] 3 #> numeric, 3 # \"numeric\" # 3 # numeric, 3  # By default, lossy casting is not allowed: local({   x <- 1.5   restrict(x = cast(type = integer())) |> try() }) #> Error in eval(quote({ : Caused by error in `restrict()`: #> ℹ In argument: `x`. #> ! Can't convert from `x` <double> to <integer> due to loss of precision. #> • Locations: 1 # Error: # Caused by error in `restrict()`: # ℹ In argument: `x`. # ! Can't convert from `x` <double> to <integer> due to loss of precision. # • Locations: 1  # Allow lossy casting using lossy_cast() or coerce() with `lossy = TRUE`: local({   x <- 1.5   restrict(x = lossy_cast(type = integer()))   cat(class(x), \", \", sep = \"\")    # or    x <- 1.5   restrict(x = coerce(type = integer(), lossy = TRUE))   cat(class(x)) }) #> integer, integer # integer, integer  # Other objects can be used as the type to cast to or size to # recycle to, e.g.: local({   x <- 1L   y <- 2.3   z <- 3L   restrict(x = coerce(type = y, size = z))   cat(class(x), length(x), sep = \", \") }) #> numeric, 3 # numeric, 3  # restrict works sequentially, so references to objects will be # after they have been evaluated: local({   x <- y <- 1L   restrict(     x = cast(type = double()),     y = cast(type = x)   )   cat(class(x), class(y), sep = \", \") }) #> numeric, numeric # numeric, numeric  # Multiple validations can be given and type and size checking can be done # within if base R checking is preferred (no coercion will occur): local({   x <- 1L   restrict(     x = validate(       ~ is.integer(.x),       ~ length(.x) == 1,       \\(.x) all(.x > 0),       \\(.x) !is.character(.x)     )   ) })  # Validations can be named for clearer error messages: local({   x <- c(1, -2, 3)   restrict(     x = validate(       \"x must be positive\" = \\(.x) all(.x > 0),     )   ) |> try() }) #> Error in eval(quote({ : Caused by error in `restrict()`: #> ℹ In argument: `x`. #> ! x must be positive # Error: # Caused by error in `restrict()`: # ℹ In argument: `x`. # ! x must be positive  # The `.env` argument determines the expression and assignment environment: local({   x <- 1L   e <- new.env()   e$x <- 1L   restrict(x = cast(type = 1.5), .env = e)   cat(class(e$x), class(x), sep = \", \") }) #> numeric, integer # numeric, integer  # Named objects (lhs) are checked to be in the `.env` environment, # throwing an error if not found: local({   x <- 1L   e <- new.env()   restrict(x = cast(type = 1.5), .env = e) |> try() }) #> Error in eval(quote({ : Caused by error in `restrict()`: #> ℹ In argument: `x`. #> ! Object `x` is not found in the `.env` environment specified. # Error: # Caused by error in `restrict()`: # ℹ In argument: `x`. # ! Object `x` is not found in the `.env` environment specified.  # For expressions (rhs), the `.env` argument is preferentially chosen, # but if not found then the normal R scoping rules apply: local({   x <- 1.5   e <- new.env()   e$z <- 1L   restrict(z = cast(type = x), .env = e) |> try()   class(e$z) }) #> [1] \"numeric\" # \"numeric\"  # the `mask` argument within the functions can be used to # restrict objects within a data mask: local({   df <- data.frame(a = 1L:3L, b = c(\"x\", \"y\", \"z\"))   restrict(     a = cast(type = double(), ~ .x > 0, mask = df),     b = validate(type = character(), ~ nchar(.x) == 1, mask = df)   )   class(df$a) }) #> [1] \"numeric\" # \"numeric\"  # The `.error_call` argument can be used to specify where the error occurs, # by default this is the caller environment. myfunc <- function(x) restrict(x = validate(size = -5)) myfunc(1) |> try() #> Error in myfunc(1) : Caused by error in `restrict()`: #> ℹ In argument: `x`. #> ! Size argument is `-5`, needs to be positive scalar integerish. # Error in `myfunc()`: # Caused by error in `restrict()`: # ℹ In argument: `x`. # ! Size argument is `-5`, needs to be positive scalar integerish.  # Injection and glue can be used: local({   x <- 1L   x_name <- \"x\"   x_list <- list(x = rlang::expr(validate(type = integer())))   restrict(     \"{x_name}\" = validate(type = integer()),     !!x_name := validate(type = integer()),     {{ x_name }} := validate(type = integer()),     !!!x_list   ) })  local({   df <- data.frame(x = 1L)   x_txt <- \"my glue error message\"   restrict(x = validate(\"{x_txt}\" = ~ .x != 1, mask = df)) |> try() }) #> Error in eval(quote({ : Caused by error in `restrict()`: #> ℹ In argument: `x` for data mask `df`. #> ! my glue error message # Error: # Caused by error in `restrict()`: # ℹ In argument: `x` for data mask `df`. # ! my glue error message"},{"path":"https://lj-jenkins.github.io/restrictr_test/reference/schema.html","id":null,"dir":"Reference","previous_headings":"","what":"Ensure the truth of data-masked R expressions — schema","title":"Ensure the truth of data-masked R expressions — schema","text":"expressions ..., evaluated within data mask .data (see rlang::args_data_masking), TRUE, rlang::abort called first expression () TRUE. .names .size arguments can used check given names size data.frame/list. checking size vctrs package (using vctrs::vec_size) thus applies vctrs size rules.","code":""},{"path":"https://lj-jenkins.github.io/restrictr_test/reference/schema.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Ensure the truth of data-masked R expressions — schema","text":"","code":"schema(.data, ...)  # S3 method for class 'data.frame' schema(   .data,   ...,   .na_rm = FALSE,   .names = NULL,   .size = NULL,   .message = NULL,   .error_call = caller_env(),   .darg = caller_arg(.data) )  # S3 method for class 'list' schema(   .data,   ...,   .na_rm = FALSE,   .names = NULL,   .size = NULL,   .message = NULL,   .error_call = caller_env(),   .darg = caller_arg(.data) )"},{"path":"https://lj-jenkins.github.io/restrictr_test/reference/schema.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Ensure the truth of data-masked R expressions — schema","text":".data data.frame list use data mask. ... number R expressions evaluated using .data data mask, evaluate (logical vector ) TRUE error occur. Positive numbers TRUE, even coerced TRUE inside () arithmetic computations R. expressions named, names used error message. Names support rlang injection glue interpreted string literals. .na_rm TRUE, NA values removed logical vectors evaluation. .names optional character vector names must present .data data.frame/list. Can glue string. .size optional positive scalar integerish value size .data data.frame/list must . .message single default error message non-named expressions. Can glue string. .error_call call environment use error messages (passed rlang::abort). .darg argument name .data use error messages.","code":""},{"path":"https://lj-jenkins.github.io/restrictr_test/reference/schema.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Ensure the truth of data-masked R expressions — schema","text":".data returned attached class with_schema attribute schema containing schema call enforced later.","code":""},{"path":"https://lj-jenkins.github.io/restrictr_test/reference/schema.html","id":"details","dir":"Reference","previous_headings":"","what":"Details","title":"Ensure the truth of data-masked R expressions — schema","text":"See schema_cast schema_recycle versions schema() attempt coerce named elements data desired type/size. See abort_if_not non-data-masked version function. restrict can also used type casting, size recycling, validation.","code":""},{"path":"https://lj-jenkins.github.io/restrictr_test/reference/schema.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Ensure the truth of data-masked R expressions — schema","text":"","code":"# NB: Some of these examples are expected to produce an error. To #     prevent them from terminating a run with example() they are #     piped into a call to try().  li <- list(x = 1, y = \"hi\", z = \\(x) x > 1) li <- schema(li, x == 1, is.character(y), is.function(z)) # all TRUE  schema(li, x == 1, is.numeric(y)) |> try() #> Error in eval(expr, envir) : Caused by error in `schema()`: #> ℹ In argument: `is.numeric(y)` for data mask `li`. #> ! Returned `FALSE`. # Error: # Caused by error in `schema()`: # ℹ In argument: `is.numeric(y)` for data mask `li`. # ! Returned `FALSE`.  # A custom error message can be given for each expression: schema(li, \"y must be numeric, check input\" = is.numeric(y)) |> try() #> Error in eval(expr, envir) : Caused by error in `schema()`: #> ℹ In argument: `is.numeric(y)` for data mask `li`. #> ! y must be numeric, check input # Error: # Caused by error in `schema()`: # ℹ In argument: `is.numeric(y)` for data mask `li`. # ! y must be numeric, check input  # Alternatively, one error message can be used for all expressions: schema(   li,   x == 1, is.character(y), is.integer(z),   .message = \"li is invalid, check input\" ) |> try() #> Error in eval(expr, envir) : Caused by error in `schema()`: #> ℹ In argument: `is.integer(z)` for data mask `li`. #> ! li is invalid, check input # Error: # Caused by error in `schema()`: # ℹ In argument: `is.integer(z)` for data mask `li`. # ! li is invalid, check input  # Option to remove NA values before checking: df <- data.frame(x = c(5, NA, 10)) df <- schema(df, x > 4, .na_rm = TRUE) # no error  # `.names` and `.size` arguments can be used to check that given names # are present and that the data has the desired (vctrs) size: schema(li, .names = c(\"a\", \"x\", \"y\", \"b\")) |> try() #> Error in eval(expr, envir) : Caused by error in `schema()`. #> ! Named elements `a` and `b` not found in data mask `li`. # Error: # Caused by error in `schema()`. # ! Named elements `a` and `b` not found in data mask `li`.  schema(li, .size = 5) |> try() #> Error in eval(expr, envir) : Caused by error in `schema()`. #> ! Object `li` is of vctrs size `3`, not `5`. # Error: # Caused by error in `schema()`. # ! Object `li` is of vctrs size `3`, not `5`.  # The `.error_call` argument can be used to specify where the error occurs, # by default this is the caller environment. myfunc <- function(df, ...) schema(df, ...) myfunc(df, x > 4) |> try() #> Error in myfunc(df, x > 4) : Caused by error in `schema()`: #> ℹ In argument: `x > 4` for data mask `df`. #> ! Contains `NA` values and `.na_rm` is set to `FALSE`. # Error in `myfunc()`: # Caused by error in `schema()`: # ℹ In argument: `x > 4` for data mask `df`. # ! Contains `NA` values and `.na_rm` is set to `FALSE`.  # Injection and glue can be used: y <- \"my error\" schema(li, \"{y}\" = x == 2) |> try() #> Error in eval(expr, envir) : Caused by error in `schema()`: #> ℹ In argument: `x == 2` for data mask `li`. #> ! my error schema(li, {{ y }} := x == 2) |> try() #> Error in eval(expr, envir) : Caused by error in `schema()`: #> ℹ In argument: `x == 2` for data mask `li`. #> ! my error schema(li, !!y := x == 2) |> try() #> Error in eval(expr, envir) : Caused by error in `schema()`: #> ℹ In argument: `x == 2` for data mask `li`. #> ! my error schema(li, x == 2, .message = \"{y}\") |> try() #> Error in eval(expr, envir) : Caused by error in `schema()`: #> ℹ In argument: `x == 2` for data mask `li`. #> ! my error # Error: # Caused by error in `schema()`: # ℹ In argument: `x == 2` for data mask `li`. # ! my error y <- list(\"my bang-bang-bang error\" = rlang::expr(x == 2)) schema(li, !!!y) |> try() #> Error in eval(expr, envir) : Caused by error in `schema()`: #> ℹ In argument: `x == 2` for data mask `li`. #> ! my bang-bang-bang error # Error: # Caused by error in `schema()`: # ℹ In argument: `x == 2` for data mask `li`. # ! my bang-bang-bang error"},{"path":"https://lj-jenkins.github.io/restrictr_test/reference/schema_cast.html","id":null,"dir":"Reference","previous_headings":"","what":"Ensure data.frame/list elements are of a specific type and cast them if not — schema_cast","title":"Ensure data.frame/list elements are of a specific type and cast them if not — schema_cast","text":"expressions ..., evaluated within data mask .data (see rlang::args_data_masking), type, data element attempts cast type specified expression. .names .size arguments can used check given names size data.frame/list. checking type type conversion vctrs package (using vctrs::vec_is vctrs::vec_cast) thus stick vctrs type conversion rules. checking size also vctrs (using vctrs::vec_size) thus applies vctrs size rules.","code":""},{"path":"https://lj-jenkins.github.io/restrictr_test/reference/schema_cast.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Ensure data.frame/list elements are of a specific type and cast them if not — schema_cast","text":"","code":"schema_cast(.data, ...)  # S3 method for class 'data.frame' schema_cast(   .data,   ...,   .lossy = FALSE,   .names = NULL,   .size = NULL,   .error_call = caller_env(),   .darg = caller_arg(.data) )  # S3 method for class 'list' schema_cast(   .data,   ...,   .lossy = FALSE,   .names = NULL,   .size = NULL,   .error_call = caller_env(),   .darg = caller_arg(.data) )"},{"path":"https://lj-jenkins.github.io/restrictr_test/reference/schema_cast.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Ensure data.frame/list elements are of a specific type and cast them if not — schema_cast","text":".data data.frame list use data mask. ... number R expressions evaluated using .data data mask. follow format named_element = expected_type, e.g, var_x = integer() var_x = var_y. .lossy TRUE, lossy casting undertaken. .names optional character vector names must present .data data.frame/list. Can glue string. .size optional positive scalar integerish value size .data data.frame/list must . .error_call call environment use error messages (passed rlang::abort). .darg argument name .data use error messages.","code":""},{"path":"https://lj-jenkins.github.io/restrictr_test/reference/schema_cast.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Ensure data.frame/list elements are of a specific type and cast them if not — schema_cast","text":"Object .data, named elements cast desired type. Also attaches class with_schema attribute schema containing schema_cast call enforced later.","code":""},{"path":"https://lj-jenkins.github.io/restrictr_test/reference/schema_cast.html","id":"details","dir":"Reference","previous_headings":"","what":"Details","title":"Ensure data.frame/list elements are of a specific type and cast them if not — schema_cast","text":"See schema schema_recycle validation recycling, well cast_if_not non-data-masked version casting. restrict can also used type casting, size recycling, validation.","code":""},{"path":"https://lj-jenkins.github.io/restrictr_test/reference/schema_cast.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Ensure data.frame/list elements are of a specific type and cast them if not — schema_cast","text":"","code":"# NB: Some of these examples are expected to produce an error. To #     prevent them from terminating a run with example() they are #     piped into a call to try().  li <- list(x = 1.1, y = \"hi\", z = 1L:2L) # Input remains the same if types match li <- schema_cast(li, x = double(), y = character(), z = integer())  # By default, lossy casting is not allowed: schema_cast(li, x = integer()) |> try() #> Error in eval(expr, envir) :  #>   Caused by error in `schema_cast()`: #> ℹ In argument: `x = integer()` for data mask `li`. #> ! Can't convert from `x` <double> to <integer> due to loss of precision. #> • Locations: 1 # Error: # Caused by error in `schema_cast()`: # ℹ In argument: `x = integer()` for data mask `li`. # ! Can't convert from `x` <double> to <integer> due to loss of precision. # • Locations: 1  # Lossy casting can be enabled with the `.lossy` argument: schema_cast(li, x = integer(), .lossy = TRUE)$x #> [1] 1  # Other objects can be used as the type to cast to, e.g.: schema_cast(li, z = x)$z |> class() #> [1] \"numeric\"  # schema_cast() works sequentially, so references to objects will be # after they have been evaluated: li$a <- 1L schema_cast(li, z = double(), a = z)$a |> class() #> [1] \"numeric\"  # `.names` and `.size` arguments can be used to check that given names # are present and that the data has the desired (vctrs) size: schema_cast(li, .names = c(\"a\", \"x\", \"y\", \"b\")) |> try() #> Error in eval(expr, envir) :  #>   Caused by error in `schema_cast()`. #> ! Named element `b` not found in data mask `li`. # Error: # Caused by error in `schema_cast()`. # ! Named elements `a` and `b` not found in data mask `li`.  schema_cast(li, .size = 5) |> try() #> Error in eval(expr, envir) :  #>   Caused by error in `schema_cast()`. #> ! Object `li` is of vctrs size `4`, not `5`. # Error: # Caused by error in `schema_cast()`. # ! Object `li` is of vctrs size `3`, not `5`.  # The `.error_call` argument can be used to specify where the error occurs, # by default this is the caller environment. myfunc <- function(li, ...) schema_cast(li, ...) myfunc(li, x = character()) |> try() #> Error in myfunc(li, x = character()) :  #>   Caused by error in `schema_cast()`: #> ℹ In argument: `x = character()` for data mask `li`. #> ! Can't convert `x` <double> to <character>. # Error in `myfunc()`: # Caused by error in `schema_cast()`: # ℹ In argument: `x = character()` for data mask `li`. # ! Can't convert `x` <double> to <character>.  # Injection and glue can be used: li <- list(x = 1L) x_name <- \"x\" schema_cast(li, \"{x_name}\" = double()) #> $x #> [1] 1 #>  #> attr(,\"class\") #> [1] \"with_schema\" \"list\"        schema_cast(li, !!x_name := double()) #> $x #> [1] 1 #>  #> attr(,\"class\") #> [1] \"with_schema\" \"list\"        schema_cast(li, {{ x_name }} := double()) #> $x #> [1] 1 #>  #> attr(,\"class\") #> [1] \"with_schema\" \"list\"        x_list <- list(x = double()) schema_cast(li, !!!x_list) #> $x #> [1] 1 #>  #> attr(,\"class\") #> [1] \"with_schema\" \"list\""},{"path":"https://lj-jenkins.github.io/restrictr_test/reference/schema_recycle.html","id":null,"dir":"Reference","previous_headings":"","what":"Ensure list elements are of a specific size and recycle them if not — schema_recycle","title":"Ensure list elements are of a specific size and recycle them if not — schema_recycle","text":"expressions ..., evaluated within data mask .data (see rlang::args_data_masking), size, data element attempts recycled size specified expression. .names .size arguments can used check given names size list. checking size recycling vctrs package (using vctrs::vec_size vctrs::vec_recycle) thus apply vctrs size rules vctrs recycling rules.","code":""},{"path":"https://lj-jenkins.github.io/restrictr_test/reference/schema_recycle.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Ensure list elements are of a specific size and recycle them if not — schema_recycle","text":"","code":"schema_recycle(.data, ...)  # S3 method for class 'list' schema_recycle(   .data,   ...,   .names = NULL,   .size = NULL,   .error_call = caller_env(),   .darg = caller_arg(.data) )"},{"path":"https://lj-jenkins.github.io/restrictr_test/reference/schema_recycle.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Ensure list elements are of a specific size and recycle them if not — schema_recycle","text":".data list use data mask. ... number R expressions evaluated using .data data mask. follow format named_element = expected_size, e.g, var_x = 10 var_x = vctrs::vec_size(var_y). .names optional character vector names must present .data data.frame/list. Can glue string. .size optional positive scalar integerish value size .data data.frame/list must . .error_call call environment use error messages (passed rlang::abort). .darg argument name .data use error messages.","code":""},{"path":"https://lj-jenkins.github.io/restrictr_test/reference/schema_recycle.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Ensure list elements are of a specific size and recycle them if not — schema_recycle","text":"Object .data, named elements recycled desired size. Also attaches class with_schema attribute schema containing schema_recycle call enforced later.","code":""},{"path":"https://lj-jenkins.github.io/restrictr_test/reference/schema_recycle.html","id":"details","dir":"Reference","previous_headings":"","what":"Details","title":"Ensure list elements are of a specific size and recycle them if not — schema_recycle","text":"See schema schema_cast validation casting, well recycle_if_not non-data-masked version recycling. restrict can also used type casting, size recycling, validation.","code":""},{"path":"https://lj-jenkins.github.io/restrictr_test/reference/schema_recycle.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Ensure list elements are of a specific size and recycle them if not — schema_recycle","text":"","code":"# NB: Some of these examples are expected to produce an error. To #     prevent them from terminating a run with example() they are #     piped into a call to try().  li <- list(x = 1, y = \"hi\", z = 1:2) schema_recycle(li, x = 5, y = 3) |> lengths() #> x y z  #> 5 3 2   # schema_recycle() follows `vctrs` recycling rules: schema_recycle(li, z = 6) |> try() #> Error in eval(expr, envir) :  #>   Caused by error in `schema_recycle()`: #> ℹ In argument: `z = 6` for data mask `li`. #> ! Can't recycle `z` (size 2) to size 6. # Error: # Caused by error in `schema_recycle()`: # ℹ In argument: `z = 6` for data mask `li`. # ! Can't recycle `z` (size 2) to size 6.  # Other objects' lengths can be used as the size to # recycle to, e.g.: schema_recycle(li, x = vctrs::vec_size(z))$x |> length() #> [1] 2  # schema_recycle() works sequentially, so references to objects will be # after they have been evaluated: li$a <- 1.25 schema_recycle(   li,   x = vctrs::vec_size(z),   a = vctrs::vec_size(x) )$a |> length() #> [1] 2  # `.names` and `.size` arguments can be used to check that given names # are present and that the data has the desired (vctrs) size: schema_recycle(li, .names = c(\"a\", \"x\", \"y\", \"b\")) |> try() #> Error in eval(expr, envir) :  #>   Caused by error in `schema_recycle()`. #> ! Named element `b` not found in data mask `li`. # Error: # Caused by error in `schema_recycle()`. # ! Named elements `a` and `b` not found in data mask `li`.  schema_recycle(li, .size = 5) |> try() #> Error in eval(expr, envir) :  #>   Caused by error in `schema_recycle()`. #> ! Object `li` is of vctrs size `4`, not `5`. # Error: # Caused by error in `schema_recycle()`. # ! Object `li` is of vctrs size `3`, not `5`.   # The `.error_call` argument can be used to specify where the error occurs, # by default this is the caller environment. myfunc <- function(li, ...) schema_recycle(li, ...) myfunc(li, x = -5) |> try() #> Error in myfunc(li, x = -5) :  #>   Caused by error in `schema_recycle()`: #> ℹ In argument: `x = -5` for data mask `li`. #> ! Size argument is `-5`, needs to be positive scalar integerish. # Error in `myfunc()`: # Caused by error in `schema_recycle()`: # ℹ In argument: `x = -5` for data mask `li`. # ! Size argument is `-5`, needs to be positive scalar integerish.  # Injection and glue can be used: li <- list(x = 1L) x_name <- \"x\" schema_recycle(li, \"{x_name}\" = 2) #> $x #> [1] 1 1 #>  #> attr(,\"class\") #> [1] \"with_schema\" \"list\"        schema_recycle(li, !!x_name := 2) #> $x #> [1] 1 1 #>  #> attr(,\"class\") #> [1] \"with_schema\" \"list\"        schema_recycle(li, {{ x_name }} := 2) #> $x #> [1] 1 1 #>  #> attr(,\"class\") #> [1] \"with_schema\" \"list\"        x_list <- list(x = 2) schema_recycle(li, !!!x_list) #> $x #> [1] 1 1 #>  #> attr(,\"class\") #> [1] \"with_schema\" \"list\""}]
