[{"path":"https://lj-jenkins.github.io/restrictr_test/LICENSE.html","id":null,"dir":"","previous_headings":"","what":"Apache License","title":"Apache License","text":"Version 2.0, January 2004 <http://www.apache.org/licenses/>","code":""},{"path":[]},{"path":"https://lj-jenkins.github.io/restrictr_test/LICENSE.html","id":"id_1-definitions","dir":"","previous_headings":"Terms and Conditions for use, reproduction, and distribution","what":"1. Definitions","title":"Apache License","text":"“License” shall mean terms conditions use, reproduction, distribution defined Sections 1 9 document. “Licensor” shall mean copyright owner entity authorized copyright owner granting License. “Legal Entity” shall mean union acting entity entities control, controlled , common control entity. purposes definition, “control” means () power, direct indirect, cause direction management entity, whether contract otherwise, (ii) ownership fifty percent (50%) outstanding shares, (iii) beneficial ownership entity. “” (“”) shall mean individual Legal Entity exercising permissions granted License. “Source” form shall mean preferred form making modifications, including limited software source code, documentation source, configuration files. “Object” form shall mean form resulting mechanical transformation translation Source form, including limited compiled object code, generated documentation, conversions media types. “Work” shall mean work authorship, whether Source Object form, made available License, indicated copyright notice included attached work (example provided Appendix ). “Derivative Works” shall mean work, whether Source Object form, based (derived ) Work editorial revisions, annotations, elaborations, modifications represent, whole, original work authorship. purposes License, Derivative Works shall include works remain separable , merely link (bind name) interfaces , Work Derivative Works thereof. “Contribution” shall mean work authorship, including original version Work modifications additions Work Derivative Works thereof, intentionally submitted Licensor inclusion Work copyright owner individual Legal Entity authorized submit behalf copyright owner. purposes definition, “submitted” means form electronic, verbal, written communication sent Licensor representatives, including limited communication electronic mailing lists, source code control systems, issue tracking systems managed , behalf , Licensor purpose discussing improving Work, excluding communication conspicuously marked otherwise designated writing copyright owner “Contribution.” “Contributor” shall mean Licensor individual Legal Entity behalf Contribution received Licensor subsequently incorporated within Work.","code":""},{"path":"https://lj-jenkins.github.io/restrictr_test/LICENSE.html","id":"id_2-grant-of-copyright-license","dir":"","previous_headings":"Terms and Conditions for use, reproduction, and distribution","what":"2. Grant of Copyright License","title":"Apache License","text":"Subject terms conditions License, Contributor hereby grants perpetual, worldwide, non-exclusive, -charge, royalty-free, irrevocable copyright license reproduce, prepare Derivative Works , publicly display, publicly perform, sublicense, distribute Work Derivative Works Source Object form.","code":""},{"path":"https://lj-jenkins.github.io/restrictr_test/LICENSE.html","id":"id_3-grant-of-patent-license","dir":"","previous_headings":"Terms and Conditions for use, reproduction, and distribution","what":"3. Grant of Patent License","title":"Apache License","text":"Subject terms conditions License, Contributor hereby grants perpetual, worldwide, non-exclusive, -charge, royalty-free, irrevocable (except stated section) patent license make, made, use, offer sell, sell, import, otherwise transfer Work, license applies patent claims licensable Contributor necessarily infringed Contribution(s) alone combination Contribution(s) Work Contribution(s) submitted. institute patent litigation entity (including cross-claim counterclaim lawsuit) alleging Work Contribution incorporated within Work constitutes direct contributory patent infringement, patent licenses granted License Work shall terminate date litigation filed.","code":""},{"path":"https://lj-jenkins.github.io/restrictr_test/LICENSE.html","id":"id_4-redistribution","dir":"","previous_headings":"Terms and Conditions for use, reproduction, and distribution","what":"4. Redistribution","title":"Apache License","text":"may reproduce distribute copies Work Derivative Works thereof medium, without modifications, Source Object form, provided meet following conditions: () must give recipients Work Derivative Works copy License; (b) must cause modified files carry prominent notices stating changed files; (c) must retain, Source form Derivative Works distribute, copyright, patent, trademark, attribution notices Source form Work, excluding notices pertain part Derivative Works; (d) Work includes “NOTICE” text file part distribution, Derivative Works distribute must include readable copy attribution notices contained within NOTICE file, excluding notices pertain part Derivative Works, least one following places: within NOTICE text file distributed part Derivative Works; within Source form documentation, provided along Derivative Works; , within display generated Derivative Works, wherever third-party notices normally appear. contents NOTICE file informational purposes modify License. may add attribution notices within Derivative Works distribute, alongside addendum NOTICE text Work, provided additional attribution notices construed modifying License. may add copyright statement modifications may provide additional different license terms conditions use, reproduction, distribution modifications, Derivative Works whole, provided use, reproduction, distribution Work otherwise complies conditions stated License.","code":""},{"path":"https://lj-jenkins.github.io/restrictr_test/LICENSE.html","id":"id_5-submission-of-contributions","dir":"","previous_headings":"Terms and Conditions for use, reproduction, and distribution","what":"5. Submission of Contributions","title":"Apache License","text":"Unless explicitly state otherwise, Contribution intentionally submitted inclusion Work Licensor shall terms conditions License, without additional terms conditions. Notwithstanding , nothing herein shall supersede modify terms separate license agreement may executed Licensor regarding Contributions.","code":""},{"path":"https://lj-jenkins.github.io/restrictr_test/LICENSE.html","id":"id_6-trademarks","dir":"","previous_headings":"Terms and Conditions for use, reproduction, and distribution","what":"6. Trademarks","title":"Apache License","text":"License grant permission use trade names, trademarks, service marks, product names Licensor, except required reasonable customary use describing origin Work reproducing content NOTICE file.","code":""},{"path":"https://lj-jenkins.github.io/restrictr_test/LICENSE.html","id":"id_7-disclaimer-of-warranty","dir":"","previous_headings":"Terms and Conditions for use, reproduction, and distribution","what":"7. Disclaimer of Warranty","title":"Apache License","text":"Unless required applicable law agreed writing, Licensor provides Work (Contributor provides Contributions) “” BASIS, WITHOUT WARRANTIES CONDITIONS KIND, either express implied, including, without limitation, warranties conditions TITLE, NON-INFRINGEMENT, MERCHANTABILITY, FITNESS PARTICULAR PURPOSE. solely responsible determining appropriateness using redistributing Work assume risks associated exercise permissions License.","code":""},{"path":"https://lj-jenkins.github.io/restrictr_test/LICENSE.html","id":"id_8-limitation-of-liability","dir":"","previous_headings":"Terms and Conditions for use, reproduction, and distribution","what":"8. Limitation of Liability","title":"Apache License","text":"event legal theory, whether tort (including negligence), contract, otherwise, unless required applicable law (deliberate grossly negligent acts) agreed writing, shall Contributor liable damages, including direct, indirect, special, incidental, consequential damages character arising result License use inability use Work (including limited damages loss goodwill, work stoppage, computer failure malfunction, commercial damages losses), even Contributor advised possibility damages.","code":""},{"path":"https://lj-jenkins.github.io/restrictr_test/LICENSE.html","id":"id_9-accepting-warranty-or-additional-liability","dir":"","previous_headings":"Terms and Conditions for use, reproduction, and distribution","what":"9. Accepting Warranty or Additional Liability","title":"Apache License","text":"redistributing Work Derivative Works thereof, may choose offer, charge fee , acceptance support, warranty, indemnity, liability obligations /rights consistent License. However, accepting obligations, may act behalf sole responsibility, behalf Contributor, agree indemnify, defend, hold Contributor harmless liability incurred , claims asserted , Contributor reason accepting warranty additional liability. END TERMS CONDITIONS","code":""},{"path":"https://lj-jenkins.github.io/restrictr_test/LICENSE.html","id":"appendix-how-to-apply-the-apache-license-to-your-work","dir":"","previous_headings":"","what":"APPENDIX: How to apply the Apache License to your work","title":"Apache License","text":"apply Apache License work, attach following boilerplate notice, fields enclosed brackets [] replaced identifying information. (Don’t include brackets!) text enclosed appropriate comment syntax file format. also recommend file class name description purpose included “printed page” copyright notice easier identification within third-party archives.","code":"Copyright 2025 Luke Jenkins  Licensed under the Apache License, Version 2.0 (the \"License\"); you may not use this file except in compliance with the License. You may obtain a copy of the License at    http://www.apache.org/licenses/LICENSE-2.0  Unless required by applicable law or agreed to in writing, software distributed under the License is distributed on an \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the License for the specific language governing permissions and limitations under the License."},{"path":"https://lj-jenkins.github.io/restrictr_test/authors.html","id":null,"dir":"","previous_headings":"","what":"Authors","title":"Authors and Citation","text":"Luke Jenkins. Author, maintainer.","code":""},{"path":"https://lj-jenkins.github.io/restrictr_test/authors.html","id":"citation","dir":"","previous_headings":"","what":"Citation","title":"Authors and Citation","text":"Jenkins L (2025). restrictr: Function Argument Validation Coercion. R package version 0.0.0.9000, https://lj-jenkins.github.io/restrictr/.","code":"@Manual{,   title = {restrictr: Function Argument Validation and Coercion},   author = {Luke Jenkins},   year = {2025},   note = {R package version 0.0.0.9000},   url = {https://lj-jenkins.github.io/restrictr/}, }"},{"path":"https://lj-jenkins.github.io/restrictr_test/index.html","id":"restrictr-","dir":"","previous_headings":"","what":"Function Argument Validation and Coercion","title":"Function Argument Validation and Coercion","text":"restrictr provides tools validation safe type coercion/recycling function arguments. Note: package still development stage subject change.","code":""},{"path":"https://lj-jenkins.github.io/restrictr_test/index.html","id":"overview","dir":"","previous_headings":"","what":"Overview","title":"Function Argument Validation and Coercion","text":"abort_if_not() general validation. cast_if_not() recycle_if_not() safe type casting recycling variables. schema() validation named elements data.frames/lists. schema_cast() schema_recycle() safe type casting recycling named elements data.frames/lists. restrict() validation, safe type casting safe recycling variables named elements data.frames/lists.","code":""},{"path":"https://lj-jenkins.github.io/restrictr_test/index.html","id":"installation","dir":"","previous_headings":"","what":"Installation","title":"Function Argument Validation and Coercion","text":"can install development version restrictr GitHub :","code":"# install.packages(\"pak\") pak::pak(\"LJ-Jenkins/restrictr\")"},{"path":"https://lj-jenkins.github.io/restrictr_test/index.html","id":"examples","dir":"","previous_headings":"","what":"Examples","title":"Function Argument Validation and Coercion","text":"abort_if_not can used validations: cast_if_not recycle_if_not provide safe casting recycling vctrs. Variables provided left hand side expected type/size provided right. Assignment automatically done back environment specified (default caller_env()): schema, schema_cast schema_recycle provide functionality data-masked arguments data.frames/lists. size data.frame/list whether certain names present can also checked using .names .size arguments. altered data-mask object returned schema_cast schema_recycle (nothing returned schema): restrict combines functionality multi-purpose tool. variables named elements within data.frames/lists can validated casted/recycled. keyword functions validate, cast, lossy_cast, recycle coerce determines whether type casting /recycling occurs. Validation functions can given, either form functions lambdas. Assignment occurs back environment specified (default caller_env()). contradictory example just show features:","code":"library(restrictr)  f <- \\(x, y) {   abort_if_not(     is.character(x),     \"`{x}` is too short!\" = nchar(x) > 5,     y$x == 1   ) }  # f(1L, list(x = 1)) # Error in `f()`: # Caused by error in `abort_if_not()`: # ℹ In argument: `is.character(x)`. # ! Returned `FALSE`.  # f(\"hi\", list(x = 1)) # Error in `f()`: # Caused by error in `abort_if_not()`: # ℹ In argument: `nchar(x) > 5`. # ! `hi` is too short! f <- \\(x, y) {   cast_if_not(x = double())   recycle_if_not(y = x)    print(class(x))   print(length(y)) }  # f(5L, 1) # [1] \"numeric\" # [1] 5  f <- \\(x) {   cast_if_not(x = integer(), .lossy = TRUE)    print(x) }  # f(1.5) # [1] 1  # f(\"hi\") # Error in `f()`: # Caused by error in `cast_if_not()`: # ℹ In argument: `x = integer()`. # ! Can't convert `x` <character> to <integer>. f <- \\(df) {   df |>     schema(x == 1) }  # f(data.frame(x = 2)) # Error in `f()`: # Caused by error in `schema()`: # ℹ In argument: `x == 1` for data mask `df`. # ! Returned `FALSE`.  f <- \\(df) {   df <- df |>     schema_cast(x = double())    print(class(df$x)) }  # f(data.frame(x = 1L)) # [1] \"numeric\"  # schema_recycle is only implemented for lists. f <- \\(li) {   li <- li |>     schema_recycle(x = 3, y = 5, z = vctrs::vec_size(x))    print(lengths(li)) }  # f(list(x = 1, y = 1, z = 1)) # x y z # 3 5 3 f <- \\(df, x) {   restrict(     df = validate(       type = data.frame(x = integer()),       size = 1,       ~ ncol(.x) == 1,       \\(.x) colnames(.x) == \"x\"     ),     x = cast(type = .env$x, mask = df),     x = coerce(type = integer(), size = df$x, lossy = TRUE)   )    cat(\"`df$x` casted to\", class(df$x), \"from the initial `x` class \\n\")   cat(\"`x` lossily casted to\", class(x), \"and recycled using value of `df$x` to length\", length(x)) }  # f(data.frame(x = 3L), 1.5) # `df$x` casted to numeric from the initial `x` class # `x` lossily casted to integer and recycled using value of `df$x` to 3  #-- vctrs type/size rules are for all `cast`, `recycle` and `coerce` calls within restrictr functions f <- \\(df) {   restrict(df = validate(type = data.frame(x = integer(), y = double()))) }  # f(data.frame(x = 1L, y = \"hi\")) # Error in `f()`: # Caused by error in `restrict()`: # ℹ In argument: `df`. # ! Returned <data.frame<\/ x: integer/ y: character/>>, not <data.frame<\/ x: integer/ y: double/>>.  f <- \\(x) {   restrict(x = recycle(size = 10)) }  # f(1:5) # Error in `f()`: # Caused by error in `restrict()`: # ℹ In argument: `x`. # ! Can't recycle `x` (size 5) to size 10."},{"path":"https://lj-jenkins.github.io/restrictr_test/index.html","id":"notes","dir":"","previous_headings":"Examples","what":"Notes","title":"Function Argument Validation and Coercion","text":"restrictr restrict inspired MATLAB’s arguments block. restrictr functions clean-case errors. typical usage within functions, little impact. However, intend continue using variables associated environments, care taken. See following example:","code":"local({   x <- 1L   y <- 1L   cast_if_not(x = double(), y = character()) |> try()   cat(     \"Code has errored but `x` has still been casted to:\",     class(x), \"\\n\",     \"in the environment specified for the `cast_if_not` call.\"   ) }) #> Error in eval(quote({ : Caused by error in `cast_if_not()`: #> ℹ In argument: `y = character()`. #> ! Can't convert `y` <integer> to <character>. #> Code has errored but `x` has still been casted to: numeric  #>  in the environment specified for the `cast_if_not` call."},{"path":"https://lj-jenkins.github.io/restrictr_test/reference/abort_if_not.html","id":null,"dir":"Reference","previous_headings":"","what":"Ensure the Truth of R Expressions — abort_if_not","title":"Ensure the Truth of R Expressions — abort_if_not","text":"expressions ... TRUE, rlang::abort called first expression () TRUE. associated error message either (hierachy): name expression, message argument, expression .","code":""},{"path":"https://lj-jenkins.github.io/restrictr_test/reference/abort_if_not.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Ensure the Truth of R Expressions — abort_if_not","text":"","code":"abort_if_not(..., .message = NULL, .na_rm = FALSE, .error_call = caller_env())"},{"path":"https://lj-jenkins.github.io/restrictr_test/reference/abort_if_not.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Ensure the Truth of R Expressions — abort_if_not","text":"... number R expressions, evaluate (logical vector ) TRUE error occur. expressions named, names used error message. .message single default error message non-named expressions. .na_rm TRUE, NA values removed logical vectors (default FALSE) .error_call call environment use error (passed rlang::abort).","code":""},{"path":"https://lj-jenkins.github.io/restrictr_test/reference/abort_if_not.html","id":"details","dir":"Reference","previous_headings":"","what":"Details","title":"Ensure the Truth of R Expressions — abort_if_not","text":"abort_if() opposite abort_if_not(), .e. expressions evaluate () FALSE error occur.","code":""},{"path":"https://lj-jenkins.github.io/restrictr_test/reference/abort_if_not.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Ensure the Truth of R Expressions — abort_if_not","text":"","code":"# NB: Some of these examples are expected to produce an error. To #     prevent them from terminating a run with example() they are #     piped into a call to try().  abort_if_not(1 == 1, all.equal(pi, 3.14159265), 1 < 2) # all TRUE  m <- matrix(c(1, 3, 3, 1), 2, 2) abort_if_not(m == t(m), diag(m) == rep(1, 2)) # all TRUE  abort_if_not(length(10)) |> try() #> Error in eval(expr, envir) :  #>   Caused by error in `abort_if_not()`: #> ℹ In argument: `length(10)`. #> ! Returned <integer>, not <logical>. # => Error: Expression `length(10)` for object `.data` must evaluate to # class <logical> not <integer>. # even when if(1) \"ok\" works  # The default error message can be overridden to be more informative: m[1, 2] <- 12 abort_if_not(\"m must be symmetric\" = m == t(m)) |> try() #> Error in eval(expr, envir) :  #>   Caused by error in `abort_if_not()`: #> ℹ In argument: `m == t(m)`. #> ! m must be symmetric # => Error: m must be symmetric  # Alternatively, one error message can be used for all expressions: abort_if_not(   m == t(m),   diag(m) == rep(1, 2),   message = \"m must be symmetric and have 1s on the diagonal.\" ) |> try() #> Error in eval(expr, envir) :  #>   Caused by error in `abort_if_not()`: #> ℹ In argument: `m == t(m)`. #> ! Returned `FALSE`. # => Error: m must be symmetric and have 1s on the diagonal.  abort_if(1 == 1) |> try() # abort_if errors if any argument does not evaluate to (all) FALSE #> Error in eval(expr, envir) :  #>   Caused by error in `abort_if()`: #> ℹ In argument: `1 == 1`. #> ! Returned `TRUE`.  # injection and glue can be used to supply expressions, names, and messages: x <- \"my error\" abort_if_not(\"{x}\" = FALSE) |> try() #> Error in eval(expr, envir) :  #>   Caused by error in `abort_if_not()`: #> ℹ In argument: `FALSE`. #> ! my error # => Error: my error y <- FALSE abort_if_not({{ x }} := !!y) |> try() #> Error in eval(expr, envir) :  #>   Caused by error in `abort_if_not()`: #> ℹ In argument: `FALSE`. #> ! my error # => Error: my error abort_if_not(!!x := !!y) |> try() #> Error in eval(expr, envir) :  #>   Caused by error in `abort_if_not()`: #> ℹ In argument: `FALSE`. #> ! my error # => Error: my error x <- list(\"my error\" = FALSE) abort_if_not(!!!x) |> try() #> Error in eval(expr, envir) :  #>   Caused by error in `abort_if_not()`: #> ℹ In argument: `FALSE`. #> ! my error # => Error: my error"},{"path":"https://lj-jenkins.github.io/restrictr_test/reference/cast_if_not.html","id":null,"dir":"Reference","previous_headings":"","what":"Check if objects are of a specific type and cast them if not — cast_if_not","title":"Check if objects are of a specific type and cast them if not — cast_if_not","text":"named expressions ... type, object attempts cast type specified expression. Expressions evaluated variables assigned environment specified .env argument. checking type type conversion vctrs package (using vctrs::vec_is vctrs::vec_cast) thus stick vctrs type conversion rules.","code":""},{"path":"https://lj-jenkins.github.io/restrictr_test/reference/cast_if_not.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Check if objects are of a specific type and cast them if not — cast_if_not","text":"","code":"cast_if_not(   ...,   .lossy = FALSE,   .env = caller_env(),   .error_call = caller_env() )"},{"path":"https://lj-jenkins.github.io/restrictr_test/reference/cast_if_not.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Check if objects are of a specific type and cast them if not — cast_if_not","text":"... number named R expressions, form : name_of_obj_to_cast = obj_of_type_to_cast_to .lossy whether allow lossy casting. .env environment use evaluation casting expressions & assignment casted variables. global environment. .error_call call environment use error (passed rlang::abort).","code":""},{"path":"https://lj-jenkins.github.io/restrictr_test/reference/cast_if_not.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Check if objects are of a specific type and cast them if not — cast_if_not","text":"","code":"# Will not alter the global environment so most examples here are wrapped with local(). x <- 1L cast_if_not(x = integer()) |> try() # => Error: Argument `call` cannot be the global environment.  local({   x <- 1L   cast_if_not(x = double())   class(x) }) #> [1] \"numeric\"  local({   x <- 1.5   cast_if_not(x = integer()) |> try() }) #> Error in eval(quote({ : Caused by error in `cast_if_not()`: #> ℹ In argument: `x = integer()`. #> ! Can't convert from `x` <double> to <integer> due to loss of precision. #> • Locations: 1 # => Error : Can't convert from `x` <double> to <integer> due to loss of precision.  local({   x <- 1.5   cast_if_not(x = integer(), .lossy = TRUE)   cat(x, class(x), sep = \", \") }) #> 1, integer  # other objects can be used as the type to cast to, e.g.: local({   x <- 1L   y <- 2.3   cast_if_not(x = y)   class(x) }) #> [1] \"numeric\"  # cast_if_not works sequentially, so references to objects will be # after they have been evaluated: local({   x <- y <- 1L   cast_if_not(x = double(), y = x)   cat(class(x), class(y), sep = \", \") }) #> numeric, numeric  myfunc <- \\(x) {   cast_if_not(x = double())   class(x) } x <- 1L myfunc(x) # x is cast to double within the function #> [1] \"numeric\" class(x) # x is still an integer outside the function #> [1] \"integer\"  local({   x <- y <- z <- 1L   cast_if_not(x = double(), y = double(), z = double())   cat(class(x), class(y), class(z), sep = \", \") }) #> numeric, numeric, numeric  # the `.env` argument determines the expression and assignment environment: local({   x <- 1L   e <- new.env()   e$x <- 1L   cast_if_not(x = 1.5, .env = e)   cat(class(e$x), class(x), sep = \", \") }) #> numeric, integer  # names (lhs) are checked to be in the `.env` environment, # throwing an error if not found: local({   x <- 1L   e <- new.env()   cast_if_not(x = 1.5, .env = e) |> try() }) #> Error in eval(quote({ : Caused by error in `cast_if_not()`. #> ! Object `x` is not found in the `.env` environment specified. # => Error: Objects `x` are not found in the `.env` environment specified.  # for expressions (rhs), the `.env` argument is preferentially chosen, but if not found # then the normal R scoping rules apply: local({   x <- 1.5   e <- new.env()   e$z <- 1L   cast_if_not(z = x, .env = e)   cat(class(e$z)) }) #> numeric"},{"path":"https://lj-jenkins.github.io/restrictr_test/reference/recycle_if_not.html","id":null,"dir":"Reference","previous_headings":"","what":"Check if objects are of a specific size and recycle them if not — recycle_if_not","title":"Check if objects are of a specific size and recycle them if not — recycle_if_not","text":"named expressions ... specified size, object attempts recycled size specified expression. Expressions evaluated variables assigned environment specified .env argument. checking size recycling vctrs package (using vctrs::vec_size vctrs::vec_recycle) thus stick vctrs recycling rules.","code":""},{"path":"https://lj-jenkins.github.io/restrictr_test/reference/recycle_if_not.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Check if objects are of a specific size and recycle them if not — recycle_if_not","text":"","code":"recycle_if_not(..., .env = caller_env(), .error_call = caller_env())"},{"path":"https://lj-jenkins.github.io/restrictr_test/reference/recycle_if_not.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Check if objects are of a specific size and recycle them if not — recycle_if_not","text":"... number named R expressions, form : name_of_obj_to_cast = size_to_cast_to .env environment use evaluation recycling expressions & assignment recycled variables. global environment. .error_call call environment use error (passed rlang::abort).","code":""},{"path":"https://lj-jenkins.github.io/restrictr_test/reference/recycle_if_not.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Check if objects are of a specific size and recycle them if not — recycle_if_not","text":"","code":"# Will not alter the global environment so most examples here are wrapped with local(). x <- 1 recycle_if_not(x = 1) |> try() # => Error: Argument `call` cannot be the global environment.  local({   x <- 1   recycle_if_not(x = 3)   x }) #> [1] 1 1 1  local({   x <- rep(1, 4)   recycle_if_not(x = 1) |> try() }) #> Error in eval(quote({ :  #>   Caused by error in `recycle_if_not()`: #> ℹ In argument: `x = 1`. #> ! Can't recycle `x` (size 4) to size 1. # => Error : Can't recycle `x` (size 4) to size 1.  local({   x <- 1L   y <- 2.3   recycle_if_not(x = 3, y = 2)   cat(x, y, sep = \", \") }) #> 1, 1, 1, 2.3, 2.3  # beware when using other objects as the size argument, e.g.: local({   x <- 1L   y <- c(1, 1, 1)   recycle_if_not(x = y) |> try() }) #> Error in eval(quote({ :  #>   Caused by error in `recycle_if_not()`: #> ℹ In argument: `x = y`. #> ! Size argument is length `3`, needs to be scalar integerish. # => Error : Size argument for `x` is not a scalar integerish value: # object length `3` of class <numeric>.  # when using other objects, call vctrs::vec_size() on them first: local({   x <- 1L   y <- c(1, 1, 1)   recycle_if_not(x = vctrs::vec_size(y))   x }) #> [1] 1 1 1  # recycle_if_not works sequentially, so references to objects will # be after they have been evaluated: local({   x <- y <- 1   recycle_if_not(x = 3, y = vctrs::vec_size(x))   cat(length(x), length(y), sep = \", \") }) #> 3, 3  myfunc <- \\(x) {   recycle_if_not(x = 3)   x } x <- 1L myfunc(x) # x is recycled to length 3 within the function #> [1] 1 1 1 x # x is still scalar outside the function #> [1] 1  local({   x <- 1   y <- 2   z <- 3   recycle_if_not(x = 2, y = 3, z = 4)   cat(x, y, z, sep = \", \") }) #> 1, 1, 2, 2, 2, 3, 3, 3, 3  # the `.env` argument determines the expression and assignment environment: local({   x <- 1   e <- new.env()   e$x <- 1   recycle_if_not(x = 3, .env = e)   cat(length(e$x), length(x), sep = \", \") }) #> 3, 1  # names (lhs) are checked to be in the `.env` environment, # throwing an error if not found: local({   x <- 1   e <- new.env()   recycle_if_not(x = 3, .env = e) |> try() }) #> Error in eval(quote({ :  #>   Caused by error in `recycle_if_not()`. #> ! Object `x` is not found in the `.env` environment specified. # Error: Objects `x` are not found in the `.env` environment specified.  # for expressions (rhs), the `.env` argument is preferentially chosen, # but if not found then the normal R scoping rules apply: local({   x <- 3   e <- new.env()   e$z <- 1   recycle_if_not(z = x, .env = e)   cat(e$z) }) #> 1 1 1"},{"path":"https://lj-jenkins.github.io/restrictr_test/reference/restrict.html","id":null,"dir":"Reference","previous_headings":"","what":"Restrict arguments to a specific type/size and test adherence to validation functions/formulas. — restrict","title":"Restrict arguments to a specific type/size and test adherence to validation functions/formulas. — restrict","text":"function takes number named expressions referring objects given environment, checking possibly coercing specified type /size, also checking number validation functions/formulas. Using function keywords validate, cast, lossy_cast, recycle, coerce within expressions allows different behaviours: validate: checks object specified type/size adheres validations, throwing error . cast: differs validate checking object specified type, attempts cast type (throwing error possible). lossy_cast: differs cast allowing lossy casting (e.g. double integer). recycle: differs validate checking object specified size, attempts recycle size (throwing error possible). coerce: differs validate checking type size, attempting cast /recycle type/size (throwing error possible). Casting lossy default can made lossy adding lossy = TRUE within coerce() call.","code":""},{"path":"https://lj-jenkins.github.io/restrictr_test/reference/restrict.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Restrict arguments to a specific type/size and test adherence to validation functions/formulas. — restrict","text":"","code":"restrict(..., .env = caller_env(), .error_call = caller_env())"},{"path":"https://lj-jenkins.github.io/restrictr_test/reference/restrict.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Restrict arguments to a specific type/size and test adherence to validation functions/formulas. — restrict","text":"... number named R expressions, names referring objects environment specified .env argument, expressions built using functions: validate(), cast(), lossy_cast(), recycle(), coerce(). .env environment use evaluation expressions & (possible) assignment variables. global environment. .error_call call environment use error (passed rlang::abort).","code":""},{"path":"https://lj-jenkins.github.io/restrictr_test/reference/restrict.html","id":"details","dir":"Reference","previous_headings":"","what":"Details","title":"Restrict arguments to a specific type/size and test adherence to validation functions/formulas. — restrict","text":"functions accept named arguments type, size mask (lossy also accepted within coerce()): type: R object desired type (e.g. integer(), double(), character(), list()). type checking casting done using vctrs package (using vctrs::vec_is vctrs::vec_cast) thus stick vctrs type conversion rules. size: scalar integerish value specifying desired size. size checking recycling done using vctrs package (using vctrs::vec_size vctrs::vec_recycle) thus stick vctrs recycling rules. mask: optional data frame list use data mask evaluations. Expressions evaluated using rlang::eval_tidy data argument set mask env argument set environment specified .env argument restrict(). mask must present within environment. na_rm: TRUE, NA values removed logical vectors validations evaluating (default FALSE). inputs unnamed validations: either expressions formulas (evaluate logical). restrict first evaluates type, size, validations. change prior expression reflected subsequent expressions, .e. object cast new type new type used size check validations. wish use vctrs type/size checking, instead give validations functions ~ .integer(.x). However, validate, cast recycle. restrict designed checking numerous objects, smaller number objects check see abort_if_not, cast_if_not, recycle_if_not, schema, schema_cast schema_recycle functions.","code":""},{"path":"https://lj-jenkins.github.io/restrictr_test/reference/restrict.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Restrict arguments to a specific type/size and test adherence to validation functions/formulas. — restrict","text":"","code":"# Will not alter the global environment so most examples here are wrapped with local(). x <- 1L restrict(x = validate(type = integer())) |> try() # => Error : Argument `.env` cannot be the global environment.  local({   x <- 1L   restrict(x = coerce(type = double(), size = 3))   cat(class(x), length(x), sep = \", \") }) #> numeric, 3  local({   x <- 1.5   restrict(x = cast(type = integer())) |> try() }) #> Error in eval(quote({ : Caused by error in `restrict()`: #> ℹ In argument: `x`. #> ! Can't convert from `x` <double> to <integer> due to loss of precision. #> • Locations: 1 # => Error : Can't convert from `x` <double> to <integer> due to loss of precision.  local({   x <- 1.5   restrict(x = lossy_cast(type = integer()))   cat(x, class(x), sep = \", \")    # or    x <- 1.5   restrict(x = coerce(type = integer(), lossy = TRUE))   cat(x, class(x), sep = \", \") }) #> 1, integer1, integer  # other objects can be used as the type to cast to or size to recycle to, e.g.: local({   x <- 1L   y <- 2.3   z <- 3L   restrict(x = coerce(type = y, size = z))   cat(class(x), length(x), sep = \", \") }) #> numeric, 3  # restrict works sequentially, so references to objects will be # after they have been evaluated: local({   x <- y <- 1L   restrict(     x = cast(type = double()),     y = cast(type = x)   )   cat(class(x), class(y), sep = \", \") }) #> numeric, numeric  # numerous validations can be given and type and size checking can be done # within if base R checking is preferred: local({   x <- 1L   restrict(     x = validate(       ~ is.integer(.x),       ~ length(.x) == 1,       \\(y) all(y > 0),       \\(z) !is.character(z)     )   ) })  # the `.env` argument determines the expression and assignment environment: local({   x <- 1L   e <- new.env()   e$x <- 1L   restrict(x = cast(type = 1.5), .env = e)   cat(class(e$x), class(x), sep = \", \") }) #> numeric, integer  # names (lhs) are checked to be in the `.env` environment, throwing an error if not found: local({   x <- 1L   e <- new.env()   restrict(x = cast(type = 1.5), .env = e) |> try() }) #> Error in eval(quote({ : Caused by error in `restrict()`: #> ℹ In argument: `x`. #> ! Object `x` is not found in the `.env` environment specified. # => Error: Objects `x` are not found in the `.env` environment specified.  # for expressions (rhs), the `.env` argument is preferentially chosen, but if not found # then the normal R scoping rules apply: local({   x <- 1.5   e <- new.env()   e$z <- 1L   restrict(x = cast(type = x), .env = e) |> try()   cat(class(e$z)) }) #> Error in eval(quote({ : Caused by error in `restrict()`: #> ℹ In argument: `x`. #> ! Object `x` is not found in the `.env` environment specified. #> integer"},{"path":"https://lj-jenkins.github.io/restrictr_test/reference/schema.html","id":null,"dir":"Reference","previous_headings":"","what":"Ensure data.frame/list elements conform to a given schema — schema","title":"Ensure data.frame/list elements conform to a given schema — schema","text":"data-masked expressions ... TRUE, rlang::abort called first expression () TRUE. .names .size arguments can used check given names size data.frame/list. checking size vctrs package (using vctrs::vec_size) thus applies vctrs size rules.","code":""},{"path":"https://lj-jenkins.github.io/restrictr_test/reference/schema.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Ensure data.frame/list elements conform to a given schema — schema","text":"","code":"schema(.data, ...)  # S3 method for class 'data.frame' schema(   .data,   ...,   .names = NULL,   .size = NULL,   .message = NULL,   .na_rm = FALSE,   .error_call = caller_env() )  # S3 method for class 'list' schema(   .data,   ...,   .names = NULL,   .size = NULL,   .message = NULL,   .na_rm = FALSE,   .error_call = caller_env() )"},{"path":"https://lj-jenkins.github.io/restrictr_test/reference/schema.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Ensure data.frame/list elements conform to a given schema — schema","text":".data data.frame list check schema . ... number R expressions evaluated using .data data-mask, evaluate (logical vector ) TRUE error occur. .names optional character vector names must present data.frame/list. .size optional scalar integerish value size data.frame/list must . .message single default error message non-named expressions. .na_rm TRUE, NA values removed logical vectors (default FALSE) .error_call call environment use error (passed rlang::abort).","code":""},{"path":"https://lj-jenkins.github.io/restrictr_test/reference/schema.html","id":"details","dir":"Reference","previous_headings":"","what":"Details","title":"Ensure data.frame/list elements conform to a given schema — schema","text":"schema_cast schema_recycle versions schema() attempt coerce data desired schema.","code":""},{"path":"https://lj-jenkins.github.io/restrictr_test/reference/schema.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Ensure data.frame/list elements conform to a given schema — schema","text":"","code":"# NB: Some of these examples are expected to produce an error. To #     prevent them from terminating a run with example() they are #     piped into a call to try().  li <- list(x = 1, y = \"hi\", z = \\(x) x > 1) li |>   schema(x == 1, is.character(y), is.function(z)) # all TRUE  li |>   schema(x == 1, is.numeric(y)) |>   try() #> Error in eval(expr, envir) : Caused by error in `schema()`: #> ℹ In argument: `is.numeric(y)` for data mask `li`. #> ! Returned `FALSE`. # => Error: Argument `is.numeric(y)` for data mask `.data` returned `FALSE`.  li |>   schema(length(x)) |>   try() #> Error in eval(expr, envir) : Caused by error in `schema()`: #> ℹ In argument: `length(x)` for data mask `li`. #> ! Returned <integer>, not <logical>. # => Error: Expression `length(x)` for object `.data` must evaluate to class # <logical> not <integer>. # even when if(1) \"ok\" works  # The default error message can be overridden to be more informative: df <- data.frame(a = 1L:3L, b = c(\"x\", \"y\", \"z\")) df |>   schema(\"a must be double\" = is.double(a)) |>   try() #> Error in eval(expr, envir) : Caused by error in `schema()`: #> ℹ In argument: `is.double(a)` for data mask `df`. #> ! a must be double # => Error: a must be double  # Alternatively, one error message can be used for all expressions: df |>   schema(     is.integer(a),     !grepl(\"x\", b),     .message = \"a must be integer and b cannot contain 'x'.\"   ) |>   try() #> Error in eval(expr, envir) : Caused by error in `schema()`: #> ℹ In argument: `!grepl(\"x\", b)` for data mask `df`. #> ! a must be integer and b cannot contain 'x'. # => Error: a must be integer and b cannot contain 'x'.  # injection and glue can be used to supply expressions, names, and messages: x <- \"my error\" schema(df, \"{x}\" = FALSE) |> try() #> Error in eval(expr, envir) : Caused by error in `schema()`: #> ℹ In argument: `FALSE` for data mask `df`. #> ! my error # => Error: my error y <- FALSE schema(df, {{ x }} := !!y) |> try() #> Error in eval(expr, envir) : Caused by error in `schema()`: #> ℹ In argument: `FALSE` for data mask `df`. #> ! my error # => Error: my error schema(df, !!x := !is.character(b)) |> try() #> Error in eval(expr, envir) : Caused by error in `schema()`: #> ℹ In argument: `!is.character(b)` for data mask `df`. #> ! my error # => Error: my error x <- list(\"my error\" = FALSE) schema(df, !!!x) |> try() #> Error in eval(expr, envir) : Caused by error in `schema()`: #> ℹ In argument: `FALSE` for data mask `df`. #> ! my error # => Error: my error"},{"path":"https://lj-jenkins.github.io/restrictr_test/reference/schema_cast.html","id":null,"dir":"Reference","previous_headings":"","what":"Ensure data.frame/list elements are of a specific type and cast them if not — schema_cast","title":"Ensure data.frame/list elements are of a specific type and cast them if not — schema_cast","text":"data-masked named expressions ... type, object attempts cast type specified expression. .names .size arguments can used check given names size data.frame/list. checking type type conversion vctrs package (using vctrs::vec_is vctrs::vec_cast) thus stick vctrs type conversion rules. checking size also vctrs (using vctrs::vec_size) thus applies vctrs size rules.","code":""},{"path":"https://lj-jenkins.github.io/restrictr_test/reference/schema_cast.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Ensure data.frame/list elements are of a specific type and cast them if not — schema_cast","text":"","code":"schema_cast(.data, ...)  # S3 method for class 'data.frame' schema_cast(   .data,   ...,   .lossy = FALSE,   .names = NULL,   .size = NULL,   .error_call = caller_env() )  # S3 method for class 'list' schema_cast(   .data,   ...,   .lossy = FALSE,   .names = NULL,   .size = NULL,   .error_call = caller_env() )"},{"path":"https://lj-jenkins.github.io/restrictr_test/reference/schema_cast.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Ensure data.frame/list elements are of a specific type and cast them if not — schema_cast","text":".data data.frame list check types schema . ... number data-masking name-value pairs evaluated using .data data-mask. follow format name = expected_type(), e.g, var_x = integer() var_x = var_y. .lossy logical, TRUE allow lossy casts. .names optional character vector names must present data.frame/list. .size optional scalar integerish value size data.frame/list must . .error_call call environment use error (passed rlang::abort).","code":""},{"path":"https://lj-jenkins.github.io/restrictr_test/reference/schema_cast.html","id":"details","dir":"Reference","previous_headings":"","what":"Details","title":"Ensure data.frame/list elements are of a specific type and cast them if not — schema_cast","text":"See also schema schema_recycle, well cast_if_not non-data-masked version casting.","code":""},{"path":"https://lj-jenkins.github.io/restrictr_test/reference/schema_cast.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Ensure data.frame/list elements are of a specific type and cast them if not — schema_cast","text":"","code":"# NB: Some of these examples are expected to produce an error. To #     prevent them from terminating a run with example() they are #     piped into a call to try().  li <- list(x = 1.1, y = \"hi\", z = 1L:2L) # input remains the same if types match li |>   schema_cast(x = double(), y = character(), z = integer()) |>   lapply(class) #> $x #> [1] \"numeric\" #>  #> $y #> [1] \"character\" #>  #> $z #> [1] \"integer\" #>   li |>   schema_cast(y = numeric()) |>   try() #> Error in eval(expr, envir) :  #>   Caused by error in `schema_cast()`: #> ℹ In argument: `y = numeric()` for data mask `li`. #> ! Can't convert `y` <character> to <double>. # => Error: Can't convert `y` <character> to <double>.  li |>   schema_cast(x = z) |>   try() #> Error in eval(expr, envir) :  #>   Caused by error in `schema_cast()`: #> ℹ In argument: `x = z` for data mask `li`. #> ! Can't convert from `x` <double> to <integer> due to loss of precision. #> • Locations: 1 # => Error: Can't convert from `x` <double> to <integer> due to loss of precision.  # with lossy casting li |>   schema_cast(x = z, .lossy = TRUE) |>   lapply(class) #> $x #> [1] \"integer\" #>  #> $y #> [1] \"character\" #>  #> $z #> [1] \"integer\" #>   # schema_cast works sequentially with quosures, so references to objects will be # after they have been evaluated: li$a <- 1L li |>   schema_cast(z = x, a = z) |>   lapply(class) #> $x #> [1] \"numeric\" #>  #> $y #> [1] \"character\" #>  #> $z #> [1] \"numeric\" #>  #> $a #> [1] \"numeric\" #>   li |>   schema_cast(x = numeric(), .size = 5) |>   try() #> Error in eval(expr, envir) :  #>   Caused by error in `schema_cast()`. #> ! Object `li` is of vctrs size `4`, not `5`. # => Error: Object `li` must have vctrs size `5`, not `4`.  li |>   schema_cast(x = numeric(), .names = c(\"x\", \"p\")) |>   try() #> Error in eval(expr, envir) :  #>   Caused by error in `schema_cast()`. #> ! Named element `p` not found in data mask `li`. # => Error: Names `p` not found in `li`.  # injection and glue can be used to supply expressions, names, and messages: li <- list(x = 1L, z = 5.5) x_name <- \"x\" schema_cast(li, !!x_name := z) |>   lapply(class) #> $x #> [1] \"numeric\" #>  #> $z #> [1] \"numeric\" #>  xg_name <- \"{x_name}\" schema_cast(li, {{ xg_name }} := character()) |> try() #> Error in eval(expr, envir) :  #>   Caused by error in `schema_cast()`: #> ℹ In argument: `x = character()` for data mask `li`. #> ! Can't convert `x` <integer> to <character>. # => Error: Can't convert `x` <integer> to <character>."},{"path":"https://lj-jenkins.github.io/restrictr_test/reference/schema_recycle.html","id":null,"dir":"Reference","previous_headings":"","what":"Ensure list elements are of a specific size and recycle them if not — schema_recycle","title":"Ensure list elements are of a specific size and recycle them if not — schema_recycle","text":"data-masked named expressions ... specified size, object attempts recycled size specified expression. .names .size arguments can used check given names size list. checking size recycling vctrs package (using vctrs::vec_size vctrs::vec_recycle) thus apply vctrs recycling rules.","code":""},{"path":"https://lj-jenkins.github.io/restrictr_test/reference/schema_recycle.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Ensure list elements are of a specific size and recycle them if not — schema_recycle","text":"","code":"schema_recycle(.data, ...)  # S3 method for class 'list' schema_recycle(   .data,   ...,   .names = NULL,   .size = NULL,   .error_call = caller_env() )"},{"path":"https://lj-jenkins.github.io/restrictr_test/reference/schema_recycle.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Ensure list elements are of a specific size and recycle them if not — schema_recycle","text":".data list check lengths schema . ... number data-masking name-value pairs evaluated using .data data-mask. follow format name = expected_size, e.g, var_x = 10L var_x = var_y. .names optional character vector names must present data.frame/list. .size optional scalar integerish value size data.frame/list must . .error_call call environment use error (passed rlang::abort).","code":""},{"path":"https://lj-jenkins.github.io/restrictr_test/reference/schema_recycle.html","id":"details","dir":"Reference","previous_headings":"","what":"Details","title":"Ensure list elements are of a specific size and recycle them if not — schema_recycle","text":"See also schema schema_recycle, well cast_if_not non-data-masked version casting.","code":""},{"path":"https://lj-jenkins.github.io/restrictr_test/reference/schema_recycle.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Ensure list elements are of a specific size and recycle them if not — schema_recycle","text":"","code":"# NB: Some of these examples are expected to produce an error. To #     prevent them from terminating a run with example() they are #     piped into a call to try().  li <- list(x = 1, y = \"hi\", z = 1:2) # li$x and li$y are recycled. li |>   schema_recycle(x = 5, y = 3) #> $x #> [1] 1 1 1 1 1 #>  #> $y #> [1] \"hi\" \"hi\" \"hi\" #>  #> $z #> [1] 1 2 #>   li |>   schema_recycle(z = 5) |>   try() #> Error in eval(expr, envir) :  #>   Caused by error in `schema_recycle()`: #> ℹ In argument: `z = 5` for data mask `li`. #> ! Can't recycle `z` (size 2) to size 5. # => Error: Can't recycle `z` (size 2) to size 5.  li |>   schema_recycle(x = \"hi\") |>   try() #> Error in eval(expr, envir) :  #>   Caused by error in `schema_recycle()`: #> ℹ In argument: `x = \"hi\"` for data mask `li`. #> ! Size argument is <character>, not <numeric>. # => Size argument for `z` is not numeric: class <character>.  # schema_recycle works sequentially with quosures, so references to objects will # be after they have been evaluated: li |>   schema_recycle(x = vctrs::vec_size(z), y = vctrs::vec_size(x)) #> $x #> [1] 1 1 #>  #> $y #> [1] \"hi\" \"hi\" #>  #> $z #> [1] 1 2 #>   li |>   schema_recycle(x = 1, .size = 5) |>   try() #> Error in eval(expr, envir) :  #>   Caused by error in `schema_recycle()`. #> ! Object `li` is of vctrs size `3`, not `5`. # => Error: Object `li` must have vctrs size `5`, not `3`.  li |>   schema_recycle(x = 1, .names = c(\"x\", \"p\")) |>   try() #> Error in eval(expr, envir) :  #>   Caused by error in `schema_recycle()`. #> ! Named element `p` not found in data mask `li`. # => Error: Names `p` not found in `li`.  # injection and glue can be used to supply expressions, names, and messages: li <- list(x = 1, z = 5) x_name <- \"x\" schema_recycle(li, !!x_name := z) #> $x #> [1] 1 1 1 1 1 #>  #> $z #> [1] 5 #>  li$x <- 1:2 xg_name <- \"{x_name}\" schema_recycle(li, {{ xg_name }} := 10) |> try() #> Error in eval(expr, envir) :  #>   Caused by error in `schema_recycle()`: #> ℹ In argument: `x = 10` for data mask `li`. #> ! Can't recycle `x` (size 2) to size 10. # => Error: Can't recycle `x` (size 2) to size 10."}]
