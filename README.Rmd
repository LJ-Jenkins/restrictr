---
output: github_document
---

<!-- README.md is generated from README.Rmd. Please edit that file -->

```{r, include = FALSE}
knitr::opts_chunk$set(
  collapse = TRUE,
  comment = "#>",
  fig.path = "man/figures/README-",
  out.width = "100%"
)
```

# restrictr <img id="logo" src="man/figures/logo.png" align="right" width="17%" height="17%" />

<!-- badges: start -->
[![R-CMD-check](https://github.com/LJ-Jenkins/restrictr/actions/workflows/R-CMD-check.yaml/badge.svg)](https://github.com/LJ-Jenkins/restrictr/actions/workflows/R-CMD-check.yaml)
<!-- badges: end -->

restrictr provides tools for the validation and safe type coercion/recycling of function arguments.

## Overview

* `abort_if_not()` for general validation.
* `cast_if_not()` and `recycle_if_not()` for safe type casting and recycling of variables.
* `schema()` for the validation of named elements of data.frames/lists.
* `schema_cast()` and `schema_recycle()` for the safe type casting and recycling of named elements of data.frames/lists.
* `enforce_schema()` to reapply the attached schema from the above functions.
* `restrict()` for validation, safe type casting and safe recycling of both variables and named elements of data.frames/lists.

## Installation

You can install the development version of restrictr from [GitHub](https://github.com/) with:

``` r
# install.packages("pak")
pak::pak("LJ-Jenkins/restrictr")
```

## Examples

`abort_if_not` can be used for all validations:

```{r abort_if_not example, error=TRUE}
library(restrictr)

f <- \(x, y) {
  abort_if_not(
    is.character(x),
    "`{x}` is too short!" = nchar(x) > 5,
    y$x == 1
  )
}

f(1L, list(x = 1))

f("hi", list(x = 1))
```

`cast_if_not` and `recycle_if_not` provide safe casting and recycling from [vctrs](https://vctrs.r-lib.org/). Variables are provided on the left hand side and the expected type/size is provided on the right. Assignment is automatically done back into the environment specified (default is the [caller_env()](https://rlang.r-lib.org/reference/stack.html)):

```{r cast_if_not and recycle_if_not examples, error=TRUE}
f <- \(x, y) {
  cast_if_not(x = double())
  recycle_if_not(y = x)

  print(class(x))
  print(length(y))
}

f(5L, 1)

f <- \(x) {
  cast_if_not(x = integer(), .lossy = TRUE)

  print(x)
}

f(1.5)

f("hi")
```

`schema`, `schema_cast` and `schema_recycle` provide the same functionality for data-masked arguments from data.frames/lists. The size of the data.frame/list and whether certain names are present can also be checked using the `.names` and `.size` arguments. The altered data-mask object is returned with an attached class `with_schema` which is used by `enforce_schema()` to reapply the original schema call:

```{r schema examples, error=TRUE}
f <- \(df) {
  df |>
    schema(x == 1)
}

f(data.frame(x = 2))

f <- \(df) {
  df <- df |>
    schema_cast(x = double())

  print(class(df$x))
}

f(data.frame(x = 1L))

# schema_recycle is only implemented for lists.
f <- \(li) {
  li <- li |>
    schema_recycle(x = 3, y = 5, z = vctrs::vec_size(x))

  print(lengths(li))
}

f(list(x = 1, y = 1, z = 1))

# enforce_schema reapplies the original call.
li <- list(x = 1, y = "hi")
li_with_schema <- schema(li, x == 1, is.character(y))
li_with_schema$y <- 1

enforce_schema(li_with_schema)

df <- data.frame(x = 1:2)
df_with_schema <- schema_cast(df, x = integer(), .lossy = TRUE)
df_with_schema$x <- c(1.5, 2.5)

enforce_schema(df_with_schema)$x

li_with_schema <- schema_recycle(li, x = 2, y = 3)
li_with_schema$y <- "hi"

enforce_schema(li_with_schema)$y
```

`restrict` combines all functionality into a multi-purpose tool. Both variables and named elements within data.frames/lists can be validated and casted/recycled. They keyword functions of `validate`, `cast`, `lossy_cast`, `recycle` and `coerce` determines whether any type casting and/or recycling occurs. Validation functions can then be given, either in the form of functions or lambdas. Assignment occurs back into the environment specified (default is the [caller_env()](https://rlang.r-lib.org/reference/stack.html)). A contradictory example just to show features:

```{r restrict example, error=TRUE}
f <- \(df, x) {
  restrict(
    df = validate(
      type = data.frame(x = integer()),
      size = 1,
      ~ ncol(.x) == 1,
      \(.x) colnames(.x) == "x"
    ),
    x = cast(type = .env$x, mask = df),
    x = coerce(type = integer(), size = df$x, lossy = TRUE)
  )

  cat("`df$x` casted to", class(df$x), "from the initial `x` class \n")
  cat("`x` lossily casted to", class(x), "and recycled using value of `df$x` to length", length(x))
}

f(data.frame(x = 3L), 1.5)

#-- vctrs type/size rules are for all `cast`, `recycle` and `coerce` calls within restrictr functions
f <- \(df) {
  restrict(df = validate(type = data.frame(x = integer(), y = double())))
}

f(data.frame(x = 1L, y = "hi"))

f <- \(x) {
  restrict(x = recycle(size = 10))
}

f(1:5)
```

###  Notes

restrictr and `restrict` were inspired by MATLAB's [arguments block](https://uk.mathworks.com/help/matlab/ref/arguments.html).

restrictr functions do not do any clean-up in the case of errors. As typical usage should be within functions, this should have little impact. However, if you intend to continue using the variables in the associated environments, care should be taken. See the following example:

```{r clean-up example}
local({
  x <- 1L
  y <- 1L
  cast_if_not(x = double(), y = character()) |> try()
  cat(
    "Code has errored but `x` has still been casted to:",
    class(x), "\n",
    "in the environment specified for the `cast_if_not` call."
  )
})
```
